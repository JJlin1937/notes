数据结构：栈、队列、集合、链表、字典、树、图、堆

进阶算法：冒泡算法、选择算法、插入算法、归并算法、快速算法、顺序算法、二分搜索

算法设计思想：分而治之、动态规划、贪心、回溯

### 1、什么是数据结构与算法

​	数据结构：计算机存储、组织数据的方式、相当于锅碗瓢盆

​	算法：一系列解决问题的清晰指令，就像食谱

​	程序：数据结构+算法

​	数据结构为算法提供服务，算法围绕数据结构操作

### 2、需要学习的内容

​	链表：遍历链表、删除链表节点

​	树、图：深度/广度优先遍历

​	数组：冒泡/选择/插入/归并/快速排序、顺序/二分搜索

### 3、时间复杂度是什么？

​	一个函数，用大O表示如：`O(1)、O(n)、O(logN)`....

​	**定性**：描述该算法的运行时间

```js
//时间复杂度：O(1)  这两行代码只会执行一次
let i = 0;
i += 1;

//时间复杂度：O(n)  for循环中代码执行了n次
for(let i = 0; i < n; i++;){
    console.log(i)
}

//时间复杂度：O(logN) 3^x = 27 => x=log(3)27   x=3;
let i = 1;
while(i < n){
    console.log(i);
    i * =2;
}
//上述代码解释：2^1、2^2、2^3直到结果>=n,

//O(1)+O(n) = O(n) 结果取增长趋势大的，忽略增长趋势小的
let i =0;
i += 1;
for (let j=0;j<n;j++){
    console.log(j)
}

//O(N)*O(n) = O(n^2);
for(let i=0;i<n;i++){
    for(let j=0;j<n;j++){
    	console.log(i,j)
    }
}
```

### 4、空间复杂度是什么？

​	一个函数，用大O表示如：O(1)、O(n)、O(n^2)....

​	算法在运行过程中临时占用存储空间大小的量度

```js
//空间复杂度：O(1)，因为只声明了单个变量，单个变量所占内存永远恒定为1
let i = 0;
i += 1;

//空间复杂度：O(n),因为list数组中添加了n个值
const list = [];
for(let i=0; i<n;i++){
    list.push(i)
}

//空间复杂度：O(n^2),因为双for循环嵌套了两层数组，存储了n^2个变量
const max = [];
for(let i=0;i<n;i++){
    max.push([])
    for(let j=0;j<n;i++){
        max[i].push(j);
    }
}
```

### 5、栈介绍

#### 栈是什么？

- 一个后进先出的数据结构
- JavaScript中没有栈，但可以用Array实现栈的功能

#### 栈的使用场景

- 需要后进先出的场景
- 如：十进制转换成二进制、判断字符串中的括号是否有效、函数调用堆栈

#### 栈常用操作：

​	push(入栈)、pop(出栈)、stack[stack.length-1]栈顶元素，就是获取数组中最后一个元素

### 6、队列

#### 队列是什么?

- 一个先进先出的数据结构
- JavaScript中没有队列，但可以用Array实现栈的功能

#### 队列的应用场景：

- 需要先入先出的场景
- 如：食堂打饭、js异步中的任务队列、计算最近请求次数

#### 队列常用操作：

​	push(入队)、shift(出队)、queue[0]获取数组中第一个元素

### 7、链表

#### 链表是什么？

- 多个元素组成的列表
- 元素存储不连续，用next指针连在一起

#### 数组vs链表

- 数组：增删非首尾元素时往往需要移动元素
- 链表：增删非首尾元素，不需要移动元素，只需要更改next的指向即可。

#### JS中的链表

- JavaScript中没有链表
- 可以用Object模拟链表

### 8、前端与链表：JS中的原型链

#### 原型链

- 原型链的本质是链表
- 原型链上的节点是各种原型对象，如：Function.prototype、Object.prototype......
- 原型链通过 `__proto__`属性连接各种原型对象。

#### 原型链长啥样？

- obj -> Object.prototype ->null
- func -> Function.prototype ->Object.prototype->null
- arr ->Array.prototype->Object.prototype->null

#### 原型链知识点

- 如果A沿着原型链能找到 B.ptototype，那么 A instanceof B 为true。
- 如果在A对象上没有找到x属性，那么会沿着原型链找到x属性 

#### 面试题

1. 简述instanceof的原理，并用代码实现

- 知识点：如果A沿着原型链能找到 B.ptototype，那么 A instanceof B 为true。

- 解法：遍历A的原型链，如果找到B.prototype，返回true，否则返回false

  ```js
  const instanceOf = (A,B)=>{
      let p = A;
      while(p){
          if(p === B.prototype){
              return true;
          }
          p = p.__proto__;
      }
      return false;
  };
  instanceOf([],Object);//true
  instanceOf([],Array);//true
  ```

  2.下题

​	知识点：如果在A对象上没有找到x属性，那么就会沿着原型链找x属性。	

​	解法：明确foo和F变量的原型链，沿着原型链找a属性和b属性。

对象的原型对象是Object，Object的原型是null；

函数的原型对象是Function，Function的原型对象是Object，Object的原型是null；

```js
var foo = {},F = function(){};
Object.prototype.a = 'value a';
Function.prototype.b = 'value b';

console.log(foo.a);
console.log(foo.b);

console.log(F.a);
console.log(F.b);
```

使用 链表指针获取JSON的节点值

```js
// 链表的遍历
const json = {
    a: { b: { c: 1 } },
    d: { e: 2 }
}

const path = ['d', 'e'];

let p = json;
path.forEach(k => {
    p = p[k]
})
```

#### 链表总结

- 链表里的元素存储不是连续的，之间通过next连接
- JavaScript中没有链表，但可以用Object模拟链表
- 链表尝一尝操作：修改next、遍历链表
- JS中的原型链也是一个链表
- 使用链表指针可以获取JSON的节点值。

### 9、集合

#### 集合什么？

- 一种**无序且唯一**的数据结构
- ES6中有集合，为Set
- 集合的常用操作：去重、判断某元素是否存在集合中、求交集...

前端与集合：使用ES6的Set

#### Set操作：

- 使用Set对象：new、add、delete、has、size
- 迭代Set：多种迭代方法、Set与Array互转、求交集/差集

```js
let mySet = new Set();//{}

mySet.add(1)
mySet.add(5)
mySet.add(5);//只会添加一个5，因为set的唯一性
mySet.add('TEXT');
let o = { a: 1, b: 2 };
mySet.add(o);
mySet.add({ a: 1, b: 2 })//会添加两个{ a: 1, b: 2 }，因为o和这个的内存地址不一样

const has = mySet.has(1);//true
const hass = mySet.has(11);//false

mySet.delete(5);

// 如何迭代一个set
for (let item of mySet)  console.log(item);
for (let item of mySet.keys())  console.log(item);
for (let item of mySet.values())  console.log(item);

// 将Set转为Array
// const myArr = [...mySet];
const myArr = Array.from(mySet);

// 将Array转为Set
const mySet2 = new Set([1,2,3,4]);

// 求交集
const intersection = new Set([...mySet].filter(x=>mySet2.has(x)));

// 求差集
const difference = new Set([...mySet].filter(x=>!mySet2.has(x)));
```

### 10、字典

#### 字典是什么？

- 与集合类似，字典也是一种存储唯一值的数据结构，但它以 **键值对** 的形式来存储
- ES6中有字典，叫Map
- 字典的常用操作：键值对的增删改查

```js
const m = new Map();

// 增
m.set('a','aa');//Map(1) {'a' => 'aa'}
m.set('b','bb');//Map(2) {'a' => 'aa', 'b' => 'bb'}

// 删
m.delete('b');//Map(1) {'a' => 'aa'}
m.clear();//删除所有的键值对

// 改
m.set('a','aaa');//Map(1) {'a' => 'aaa'}

// 查
m.get('a');//'aaa'
```

### 11、树

#### 树是什么？

- 一种 **分层** 数据的抽象模型
- 前端工作中常见的树包括：DOM树、级联选择、树形控件...
- JS中没有树，但是可以用Object 和 Array构建树
- 树的常用操作：深度/广度优先遍历、先中后序遍历。

#### 什么是深度/广度优先遍历？

- 深度优先遍历：尽可能深的搜索树的分支
- 广度优先遍历：先访问离根节点最近的节点

#### 深度优先遍历的算法口诀

- 访问根节点
- 对根节点的children挨个进行深度优先遍历

#### 广度优先遍历的算法口诀

- 新建一个队列，把根节点入队
- 把队头出队并访问
- 把队头的children挨个入队
- 重复第二、三步，直到队列为空

#### 二叉树的先中后序遍历

##### 二叉树是什么？

- 树中每个节点最多只能有两个子节点。
- 在JS中通常用Object来模拟二叉树。

##### 先序遍历算法口诀

- 访问 **根** 节点。
- 对根节点的 **左** 子树进行先序遍历。
- 对根节点的 **右** 子树进行先序遍历。

##### 中序遍历算法口诀

- 对根节点的 **左** 子树进行中序遍历。
- 访问 **根** 节点。
- 对根节点的 **右** 子树进行中序遍历。

##### 后序遍历算法口诀

- 对根节点的 **左** 子树进行后序遍历。
- 对根节点的 **右** 子树进行后序遍历
- 访问 **根** 节点。

### 二叉树的先中后序遍历 (非递归版)

##### 先序遍历

```js
// 先序遍历(非递归版) 根 左 右  使用堆栈模拟递归过程
const preorder = (root) => {
    if (!root) { return; }
    const stack = [root];
    while (stack.length) {
        const n = stack.pop();
        console.log(n.val);//访问根节点的值
        if (n.right) stack.push(n.right);
        if (n.left) stack.push(n.left);//因为栈是后进先出，为保证先访问left则先push right
    }

}

preorder(bt);//1 2 4 5 3 6 7
```

##### 中序遍历

```js
// 中序遍历(非递归版) 左 根 右  
const inorder = (root) => {
    // 拦截根节点为空
    if (!root) { return; }
    const stack = [];
    let p = root;
    while (stack.length || p) {
        while (p) {
            stack.push(p);
            p = p.left;
        }
        const n = stack.pop();
        console.log(n.val);
        p = n.right;
    }
}


inorder(bt);//4 2 5 1 6 3 7
```

##### 后序遍历

```js
// 后序遍历(非递归版) 左  右  根
// 后序遍历 左 右 根反过来，和先序遍历的 根 左 右差不多，可以用先序遍历实现
const postorder = (root) => {
    // 拦截根节点为空
    if (!root) { return; }
    const outputStack = [];//实现倒置的栈
    const stack = [root];
    while (stack.length) {
        const n = stack.pop();
        outputStack.push(n);
        if (n.right) stack.push(n.right);//此处调换了left 和 right的入栈顺序，则结果为根 右 左
        if (n.left) stack.push(n.left);
    }
    while (outputStack.length) {
        const n = outputStack.pop();//倒序输出节点就是 左 右 根
        console.log(n.val);//访问根节点的值
    }
}

postorder(bt);//4 5 2 6 7 3 1
```

#### 前端与树：遍历`JSON`的所有节点值（深度优先遍历）

```js
const json = {
    a: { b: { c: 1 } },
    d: [1, 2],
}

// 使用深度优先遍历访问json里面的所有值
const dfs = (n) => {
    console.log(n,path);//访问当前节点
    Object.keys(n).forEach(k => {// Object.keys(n)拿到所有的key
        dfs(n[k], path.concat(k));//n[k] 就是所有的孩子节点
    });
};

dfs(json,[]);
```

### 12、图

#### 图是什么？

- 图是 **网络结构** 的抽象模型，是一组由 **边** 连接的 **节点** 。
- 图可以表示任何二元关系，比如道路、航班...
- `JS`中没有图，但我们可以使用Object和Array构建图。
- 图的表示法：邻接矩阵、邻接表、关联矩阵......

#### 图的深度与广度优先遍历

- 深度优先遍历：尽可能深的搜索图的分支。
- 广度优先遍历：先访问离根节点最近的节点。

#### 图的深度优先遍历算法口诀

- 访问根节点
- 对根节点的 **没访问过的相邻节点** 挨个进行深度优先遍历。

#### 图的广度优先遍历算法口诀

- 新建一个队列，把根节点入队
- 把队头出队并访问。
- 把队头的 **没访问过的相邻节点** 入队。
- 重复第二、三步，直到队列为空。











































