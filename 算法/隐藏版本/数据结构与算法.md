数据结构：栈、队列、集合、链表、字典、树、图、堆

进阶算法：冒泡算法、选择算法、插入算法、归并算法、快速算法、顺序算法、二分搜索

算法设计思想：分而治之、动态规划、贪心、回溯

### 1、什么是数据结构与算法

​	数据结构：计算机存储、组织数据的方式、相当于锅碗瓢盆

​	算法：一系列解决问题的清晰指令，就像食谱

​	程序：数据结构+算法

​	数据结构为算法提供服务，算法围绕数据结构操作

### 2、需要学习的内容

​	链表：遍历链表、删除链表节点

​	树、图：深度/广度优先遍历

​	数组：冒泡/选择/插入/归并/快速排序、顺序/二分搜索

### 3、时间复杂度是什么？

​	一个函数，用大O表示如：`O(1)、O(n)、O(logN)`....

​	**定性**：描述该算法的运行时间

```js
//时间复杂度：O(1)  这两行代码只会执行一次
let i = 0;
i += 1;

//时间复杂度：O(n)  for循环中代码执行了n次
for(let i = 0; i < n; i++;){
    console.log(i)
}

//时间复杂度：O(logN) 3^x = 27 => x=log(3)27   x=3;
let i = 1;
while(i < n){
    console.log(i);
    i * =2;
}
//上述代码解释：2^1、2^2、2^3直到结果>=n,

//O(1)+O(n) = O(n) 结果取增长趋势大的，忽略增长趋势小的
let i =0;
i += 1;
for (let j=0;j<n;j++){
    console.log(j)
}

//O(N)*O(n) = O(n^2);
for(let i=0;i<n;i++){
    for(let j=0;j<n;j++){
    	console.log(i,j)
    }
}
```

### 4、空间复杂度是什么？

​	一个函数，用大O表示如：O(1)、O(n)、O(n^2)....

​	算法在运行过程中临时占用存储空间大小的量度

```js
//空间复杂度：O(1)，因为只声明了单个变量，单个变量所占内存永远恒定为1
let i = 0;
i += 1;

//空间复杂度：O(n),因为list数组中添加了n个值
const list = [];
for(let i=0; i<n;i++){
    list.push(i)
}

//空间复杂度：O(n^2),因为双for循环嵌套了两层数组，存储了n^2个变量
const max = [];
for(let i=0;i<n;i++){
    max.push([])
    for(let j=0;j<n;i++){
        max[i].push(j);
    }
}
```

### 5、栈介绍

#### 栈是什么？

- 一个后进先出的数据结构
- JavaScript中没有栈，但可以用Array实现栈的功能

#### 栈的使用场景

- 需要后进先出的场景
- 如：十进制转换成二进制、判断字符串中的括号是否有效、函数调用堆栈

#### 栈常用操作：

​	push(入栈)、pop(出栈)、stack[stack.length-1]栈顶元素，就是获取数组中最后一个元素

### 6、队列

#### 队列是什么?

- 一个先进先出的数据结构
- JavaScript中没有队列，但可以用Array实现栈的功能

#### 队列的应用场景：

- 需要先入先出的场景
- 如：食堂打饭、js异步中的任务队列、计算最近请求次数

#### 队列常用操作：

​	push(入队)、shift(出队)、queue[0]获取数组中第一个元素

### 7、链表

#### 链表是什么？

- 多个元素组成的列表
- 元素存储不连续，用next指针连在一起

#### 数组vs链表

- 数组：增删非首尾元素时往往需要移动元素
- 链表：增删非首尾元素，不需要移动元素，只需要更改next的指向即可。

#### JS中的链表

- JavaScript中没有链表
- 可以用Object模拟链表

### 8、前端与链表：JS中的原型链

#### 原型链

- 原型链的本质是链表
- 原型链上的节点是各种原型对象，如：Function.prototype、Object.prototype......
- 原型链通过 `__proto__`属性连接各种原型对象。

#### 原型链长啥样？

- obj -> Object.prototype ->null
- func -> Function.prototype ->Object.prototype->null
- arr ->Array.prototype->Object.prototype->null

#### 原型链知识点

- 如果A沿着原型链能找到 B.ptototype，那么 A instanceof B 为true。
- 如果在A对象上没有找到x属性，那么会沿着原型链找到x属性 

#### 面试题

1. 简述instanceof的原理，并用代码实现

- 知识点：如果A沿着原型链能找到 B.ptototype，那么 A instanceof B 为true。

- 解法：遍历A的原型链，如果找到B.prototype，返回true，否则返回false

  ```js
  const instanceOf = (A,B)=>{
      let p = A;
      while(p){
          if(p === B.prototype){
              return true;
          }
          p = p.__proto__;
      }
      return false;
  };
  instanceOf([],Object);//true
  instanceOf([],Array);//true
  ```

  2.下题

​	知识点：如果在A对象上没有找到x属性，那么就会沿着原型链找x属性。	

​	解法：明确foo和F变量的原型链，沿着原型链找a属性和b属性。

对象的原型对象是Object，Object的原型是null；

函数的原型对象是Function，Function的原型对象是Object，Object的原型是null；

```js
var foo = {},F = function(){};
Object.prototype.a = 'value a';
Function.prototype.b = 'value b';

console.log(foo.a);
console.log(foo.b);

console.log(F.a);
console.log(F.b);
```

使用 链表指针获取JSON的节点值

```js
// 链表的遍历
const json = {
    a: { b: { c: 1 } },
    d: { e: 2 }
}

const path = ['d', 'e'];

let p = json;
path.forEach(k => {
    p = p[k]
})
```

#### 链表总结

- 链表里的元素存储不是连续的，之间通过next连接
- JavaScript中没有链表，但可以用Object模拟链表
- 链表尝一尝操作：修改next、遍历链表
- JS中的原型链也是一个链表
- 使用链表指针可以获取JSON的节点值。

### 9、集合

#### 集合什么？

- 一种**无序且唯一**的数据结构
- ES6中有集合，为Set
- 集合的常用操作：去重、判断某元素是否存在集合中、求交集...

前端与集合：使用ES6的Set

#### Set操作：

- 使用Set对象：new、add、delete、has、size
- 迭代Set：多种迭代方法、Set与Array互转、求交集/差集

```js
let mySet = new Set();//{}

mySet.add(1)
mySet.add(5)
mySet.add(5);//只会添加一个5，因为set的唯一性
mySet.add('TEXT');
let o = { a: 1, b: 2 };
mySet.add(o);
mySet.add({ a: 1, b: 2 })//会添加两个{ a: 1, b: 2 }，因为o和这个的内存地址不一样

const has = mySet.has(1);//true
const hass = mySet.has(11);//false

mySet.delete(5);

// 如何迭代一个set
for (let item of mySet)  console.log(item);
for (let item of mySet.keys())  console.log(item);
for (let item of mySet.values())  console.log(item);

// 将Set转为Array
// const myArr = [...mySet];
const myArr = Array.from(mySet);

// 将Array转为Set
const mySet2 = new Set([1,2,3,4]);

// 求交集
const intersection = new Set([...mySet].filter(x=>mySet2.has(x)));

// 求差集
const difference = new Set([...mySet].filter(x=>!mySet2.has(x)));
```

### 10、字典

#### 字典是什么？

- 与集合类似，字典也是一种存储唯一值的数据结构，但它以 **键值对** 的形式来存储
- ES6中有字典，叫Map
- 字典的常用操作：键值对的增删改查

```js
const m = new Map();

// 增
m.set('a','aa');//Map(1) {'a' => 'aa'}
m.set('b','bb');//Map(2) {'a' => 'aa', 'b' => 'bb'}

// 删
m.delete('b');//Map(1) {'a' => 'aa'}
m.clear();//删除所有的键值对

// 改
m.set('a','aaa');//Map(1) {'a' => 'aaa'}

// 查
m.get('a');//'aaa'
```

### 11、树

#### 树是什么？

- 一种 **分层** 数据的抽象模型
- 前端工作中常见的树包括：DOM树、级联选择、树形控件...
- JS中没有树，但是可以用Object 和 Array构建树
- 树的常用操作：深度/广度优先遍历、先中后序遍历。

#### 什么是深度/广度优先遍历？

- 深度优先遍历：尽可能深的搜索树的分支
- 广度优先遍历：先访问离根节点最近的节点

#### 深度优先遍历的算法口诀

- 访问根节点
- 对根节点的children挨个进行深度优先遍历

#### 广度优先遍历的算法口诀

- 新建一个队列，把根节点入队
- 把队头出队并访问
- 把队头的children挨个入队
- 重复第二、三步，直到队列为空

#### 二叉树的先中后序遍历

##### 二叉树是什么？

- 树中每个节点最多只能有两个子节点。
- 在JS中通常用Object来模拟二叉树。

##### 先序遍历算法口诀

- 访问 **根** 节点。
- 对根节点的 **左** 子树进行先序遍历。
- 对根节点的 **右** 子树进行先序遍历。

##### 中序遍历算法口诀

- 对根节点的 **左** 子树进行中序遍历。
- 访问 **根** 节点。
- 对根节点的 **右** 子树进行中序遍历。

##### 后序遍历算法口诀

- 对根节点的 **左** 子树进行后序遍历。
- 对根节点的 **右** 子树进行后序遍历
- 访问 **根** 节点。

### 二叉树的先中后序遍历 (非递归版)

##### 先序遍历

```js
// 先序遍历(非递归版) 根 左 右  使用堆栈模拟递归过程
const preorder = (root) => {
    if (!root) { return; }
    const stack = [root];
    while (stack.length) {
        const n = stack.pop();
        console.log(n.val);//访问根节点的值
        if (n.right) stack.push(n.right);
        if (n.left) stack.push(n.left);//因为栈是后进先出，为保证先访问left则先push right
    }

}

preorder(bt);//1 2 4 5 3 6 7
```

##### 中序遍历

```js
// 中序遍历(非递归版) 左 根 右  
const inorder = (root) => {
    // 拦截根节点为空
    if (!root) { return; }
    const stack = [];
    let p = root;
    while (stack.length || p) {
        while (p) {
            stack.push(p);
            p = p.left;
        }
        const n = stack.pop();
        console.log(n.val);
        p = n.right;
    }
}


inorder(bt);//4 2 5 1 6 3 7
```

##### 后序遍历

```js
// 后序遍历(非递归版) 左  右  根
// 后序遍历 左 右 根反过来，和先序遍历的 根 左 右差不多，可以用先序遍历实现
const postorder = (root) => {
    // 拦截根节点为空
    if (!root) { return; }
    const outputStack = [];//实现倒置的栈
    const stack = [root];
    while (stack.length) {
        const n = stack.pop();
        outputStack.push(n);
        if (n.right) stack.push(n.right);//此处调换了left 和 right的入栈顺序，则结果为根 右 左
        if (n.left) stack.push(n.left);
    }
    while (outputStack.length) {
        const n = outputStack.pop();//倒序输出节点就是 左 右 根
        console.log(n.val);//访问根节点的值
    }
}

postorder(bt);//4 5 2 6 7 3 1
```

#### 前端与树：遍历`JSON`的所有节点值（深度优先遍历）

```js
const json = {
    a: { b: { c: 1 } },
    d: [1, 2],
}

// 使用深度优先遍历访问json里面的所有值
const dfs = (n) => {
    console.log(n,path);//访问当前节点
    Object.keys(n).forEach(k => {// Object.keys(n)拿到所有的key
        dfs(n[k], path.concat(k));//n[k] 就是所有的孩子节点
    });
};

dfs(json,[]);
```

### 12、图

#### 图是什么？

- 图是 **网络结构** 的抽象模型，是一组由 **边** 连接的 **节点** 。
- 图可以表示任何二元关系，比如道路、航班...
- `JS`中没有图，但我们可以使用Object和Array构建图。
- 图的表示法：邻接矩阵、邻接表、关联矩阵......

#### 图的深度与广度优先遍历

- 深度优先遍历：尽可能深的搜索图的分支。
- 广度优先遍历：先访问离根节点最近的节点。

#### 图的深度优先遍历算法口诀

- 访问根节点
- 对根节点的 **没访问过的相邻节点** 挨个进行深度优先遍历。

#### 图的广度优先遍历算法口诀

- 新建一个队列，把根节点入队
- 把队头出队并访问。
- 把队头的 **没访问过的相邻节点** 入队。
- 重复第二、三步，直到队列为空。

### 13、堆

#### 堆是什么？

- 堆是一种特殊的完全二叉树。
- 所有的节点都大于等于（最大堆）或小于等于（最小堆）它的子节点。

#### `JS`中的堆

- `js`中常用数组表示堆。
- 左侧子节点的位置是 2 * index + 1。
- 右侧子节点的位置是 2 * index + 2。
- 父节点位置是(index-1) / 2。

#### 堆的应用

- 堆能高效、快速地找出最大值和最小值，时间复杂度：O(1).。对顶固定是最大值(堆)或最小值(堆)。
- 找出第K个最大(小)元素。

#### 如何找出第 K 个最大元素

- 构建一个最小堆，并将元素依次插入堆中。
- 当堆的容量超过K，就删除堆顶。
- 插入结束后，堆顶就是第 K 个最大元素。

找出第 K 个最小元素就是构建一个最大堆。

### JavaScript实现：最小堆类

#### 实现步骤

- 在类里，声明一个数组，用来装元素。
- 主要方法：插入、删除堆顶、获取堆顶、获取堆大小。

#### 插入

- 将值插入堆的底部，即数组的尾部。
- 然后上移动：将这个值和它的父节点进行交换，直到父节点小于等于这个插入的值。
- 大小为k的堆中插入元素的世界复杂的为`O(logK)`。

#### 删除堆顶

- 用数组尾部元素替换堆顶（直接删除堆顶会破坏堆结构）。
- 然后下移：将新堆顶和它的子节点进行交换，直到子节点大于等于这个新堆顶。
- 大小为k的堆中删除堆顶的时间复杂度为`O(logK)`。

#### 获取堆顶和堆的大小

- 获取堆顶：返回数组的头部。
- 获取堆的大小：返回数组的长度。

### 14、排序和搜索

#### 排序和搜索是什么？

- 排序：把某个乱序的数组变成升序或者降序的数组。
- 搜索：找出数组中某个元素的下标。

#### `JS`中的排序和搜索

- `JS`中的排序：数组的 sort 方法。
- `JS`中的搜索：数组的 `indexOf`方法。

排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序......

搜索算法：顺序搜索、二分搜索 ......

#### JavaScript实现：冒泡排序 

冒泡排序思路

- 比较所有相邻元素，如果第一个比第二个大，则交换它们。
- 一轮下来，可以保证最后一个数是最大的。
- 执行 n-1 轮，就可以完成排序。

冒泡排序的时间复杂度 (所有排序中性能最差的排序)

- 两个嵌套循环。
- 时间复杂度：O(n^2)。

#### JavaScript实现：选择排序 

选择排序思路

- 找到数组中的最小值，选中它并将其放置在第一位。
- 找到数组中第二小的值，选中它并将其放置在第二位。
- 以此类推，执行 n-1 轮。

选择排序的时间复杂度 (所有排序中性能第二差的排序)

- 两个嵌套循环。
- 时间复杂度：O(n^2)。

#### JavaScript实现：插入排序 

插入排序思路

- 从第二个数开始往后比。
- 比它大就往后排。
- 以此类推进行到最后一个数。

插入排序的时间复杂度  (所有排序中性能第三差的排序)

- 两个嵌套循环。
- 时间复杂度：O(n^2)。

#### JavaScript实现：归并排序 

归并排序思路

- 分：把数组劈成两半，再递归地对子数组进行 "分" 操作，直到分成一个个单独的数。
- 合：把两个数合并为有序数组，再对有序数组进行合并，直到全部子数组合并为一个完整数组。

合并两个有序数组

- 新建一个空数组res，用于存放最终排序后的数组。
- 比较两个有序数组的头部，较小者出队并推入 res 中。
- 如果两个数组还有值，就重复第二步。

归并排序的时间复杂度 

- 分的时间复杂度是`O(logN)`。
- 合的时间复杂度是 O(n)。
- 时间复杂度：`O(n*logN)`。

#### JavaScript实现：快速排序 

快速排序思路

- 分区：从数组中任意选择一个“基准”，所有比基准小的元素放在基准前面，比基准大的元素放在基准后面。
- 递归：递归地对基准前后的子数组进行分区。

快速排序的时间复杂度 

- 递归的时间复杂度是`O(logN)`。
- 分区的时间复杂度是 O(n)。
- 时间复杂度：`O(n*logN)`。

#### JavaScript实现：顺序搜索 

顺序搜索思路

- 遍历数组
- 找到跟目标值相等的元素，就返回它的下标。
- 遍历结束后，如果没有搜索到目标值，就返回-1。

顺序搜索的时间复杂度 

- 遍历数组是一个循环操作。
- 时间复杂度：`O(n)`。

#### JavaScript实现：二分搜索 (前提数组是有序的)

二分搜索思路

- 从数组的中间元素开始，如果中间元素正好是目标值，则搜索结束。
- 如果目标值大于或小于中间元素，则在大于或小于中间元素的那一半数组中搜索。

二分搜索的时间复杂度 

- 每一次比较都使搜索范围缩小一半。
- 时间复杂度：`O(logN)`。

### 15、分而治之

#### 什么是分而治之？

- 分而治之是 **算法设计** 中的一种方法。
- 它将一个问题 **分** 成多个和原问题相似的小问题，**递归解决** 小问题，再将结果 **合** 并以解决原来的问题。

#### 场景一：归并排序

- 分：把数组从中间一分为二。
- 解：递归的对两个子数组进行归并排序。
- 合：合并有序子数组。

#### 场景二：快速排序

- 分：选基准，按基准把数组分成两个子数组。
- 解：递归的对两个子数组进行快速排序。
- 合：对两个子数组进行合并。

#### 动态规划是什么？

- 动态规划是 **算法设计** 中的一种方法。
- 它将一个问题分解为 **相互重叠** 的子问题，通过反复求解子问题，来解决原来的问题。

#### 动态规划步骤

- 定义子问题。
- 反复执行。

#### 比如斐波那契数列  0  1   1  2   3   5   8   13   21   34 ....

- 定义子问题：F(n) = F(n-1) + F(n-2)。
- 反复执行：从2循环到n，执行上述公式。

#### 动态规划 vs 分而治之

- 子问题相互重叠 动态规划
- 子问题相互独立 分而治之

### 17、贪心算法

#### 贪心算法是什么？

- 贪心算法是 **算法设计** 中的一种方法。
- 期盼通过每个阶段的 **局部最优** 选择，从而达到全局的最优。
- 结果 **并不一定是最优**。

### 18、回溯算法

#### 回溯算法是什么？（走一条路没走通，拐回来再走就叫回溯）

- 回溯算法是 **算法设计** 中的一种方法。
- 回溯算法是一种 **渐进式** 寻找并构建问题解决方式的策略。
- 回溯算法会先从一个可能的动作开始解决问题，如果不行，就回溯并选择另一个动作，直到将问题解决。

#### 什么问题适合用回溯算法解决？

- 有很多路(路径、组合)。
- 这些路里面，有死路(不符合的)，也有 出路(答案)。
- 通常需要递归来模拟所有的路。

#### 全排列

- 用递归模拟出所有情况。

- 遇到包含重复元素的情况，就回溯。

- 收集所有到达递归终点的情况，并返回。

- 输入：[1,2,3] 

- 输出 [

  [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1],

  ​	]



























