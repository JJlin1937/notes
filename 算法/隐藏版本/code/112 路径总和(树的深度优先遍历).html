<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 
        给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

        输入：root = [1,2,3], targetSum = 5
        输出：false
        解释：树中存在两条根节点到叶子节点的路径：
        (1 -> 2): 和为 3
        (1 -> 3): 和为 4
        不存在 sum = 5 的根节点到叶子节点的路径。

        解题思路：
            1.在深度优先遍历的过程中，记录当前路径的节点值的和。
            2.在叶子节点处，判断当前路径的节点值的和是否等于目标值。
        
        解题步骤：
            1.深度优先遍历二叉树，在叶子节点处，判断当前路径的节点值的和是否等于目标值，是就返回true
            2.遍历结束，如果没有匹配，就返回false。
     -->
    <script>
        var hasPathSum = function (root, sum) {
            if (!root) return false;
            const dfs = (n, s) => {
                // 判断当前节点是叶子节点
                if(!n.left && !n.right && s === sum){
                    res = true;
                }
                if (n.left) dfs(n.left, s + n.left.val);
                if (n.right) dfs(n.right, s + n.right.val);
            }
            dfs(root, root.val);
            return res;
        }

        // 时间复杂度：On,n是整棵树的节点数
        // 空间复杂度：使用了递归，On,n树的高度
        //     最差：On (二叉树不分叉，只在一个节点上向下分)
        //     最好: OlogN (均匀的左右分叉的二叉树)

    </script>
</body>

</html>