[TOC]
## 1.Html5和CSS3

### 常见的水平垂直居中实现方案

- 最简单的方案 flex布局

  ```css
  .father {
      display:flex;
      justify-content:center;
      align-items: center;
  }
  .son {
      ...
  }
  ```

- 绝对定位配合margin:auto，实现

  ```css
  .father {
      position: relative;
  }
  .son {
      position: absolute;
      top:0;
      left:0;
      bottom: 0;
      right:0;
      margin: auto;
  }
  ```

- 绝对定位配合transform实现

  ```css
  .father {
      position: relative;
  }
  .son {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%)
  }
  ```

### BFC问题

BFC：块格式上下文，是一块独立的渲染区域，内部元素不会影响外部的元素。

**flex:1;是哪些属性的缩写，对应的属性代表什么含义**

flex:1;在浏览器中查看分别是flex-grow（设置了对应元素的增长系数）、flex-shrink（指定了对应元素的收缩规则，只有在所有元素的默认宽度之和大于容器宽度时才会触发）、flex-basis（指定了对应元素在主轴上的大小）

```css
flex: 1;
  flex-grow: 1;
  flex-shrink: 1;
  flex-basis: 0%;
```

隐藏元素的属性

- display：none；
- visibility：hidden；
- opacity：0；

## 2.js相关

### 1) JS基础类型，typeof和instanceof的区别

基础类型有：boolean、string、number、null、undefined、symbol、bigint。

typeof 能识别所有的值类型，识别函数，能区分是否是引用类型。\

```js
typeof "123" ==> str        typeof 123  ==> number    typeof BigInt(9007199254740991) ==> bigint
typeof false  ==> boolean   typeof undefined ==> undefined  typeof ()=>{}  ==> function
typeof null ==> object     typeof []  ==> object      typeof  Symbol("f") ==> symbol
```

instanceof用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。

### 2) 数组的forEach和map方法有哪些区别？常用哪些方法对数组进行增、删、改

- forEach是对数组的每一个元素执行一次给定的函数。
- map是创建一个新数组，该新数组由原数组的每个元素都调用一次提供的函数返回的值。
- pop()：删除数组后面的最后一个元素，返回值为**被删除的**那个元素
- push()：将一个元素或多个元素添加到数组末尾，并返回**新的长度**。
- shift()：删除数组中的第一个元素，并返回被删除元素的值。
- unshift()：将一个或多个元素添加到数组的**开头**，并返回该数组的**新长度**。
- splice()：通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容
- reverse()：反转数组。

```js
const arr = [1,2,3,4,5,6]
arr.forEach(x => {
    x = x +1 ;
    console.log(x);
});
// x :>>  2
// x :>>  3
// x :>>  4
// x :>>  5
// x :>>  6
// x :>>  7
console.log(arr);
//[ 1, 2, 3, 4, 5, 6 ]

const mapArr = arr.map(x => {
    x = x*2;
    return x;
});
console.log("mapArr :>> ", mapArr); // [ 2, 4, 6, 8, 10, 12 ]
console.log("arr :>> ", arr); //  [ 1, 2, 3, 4, 5, 6 ]

const popArr = arr.pop();
console.log("popArr :>> ", popArr); // popArr :>>  6
console.log("arr :>> ", arr); // arr :>>  [ 1, 2, 3, 4, 5 ]

const pushArr = arr.push("a");
console.log("pushArr :>> ", pushArr); // pushArr :>>  6
console.log("arr :>> ", arr); // arr :>>  [ 1, 2, 3, 4, 5, 'a' ]

const shiftArr = arr.shift();
console.log("shiftArr :>> ", shiftArr); // shiftArr :>>  1
console.log("arr :>> ", arr); // arr :>>  [ 2, 3, 4, 5, 'a' ]

const unshiftArr = arr.unshift("b", "c");
console.log("unshiftArr :>> ", unshiftArr); // unshiftArr :>>  7
console.log("arr :>> ", arr); // arr :>>  ['b', 'c', 2,3,4,5,'a']

const spliceArr = arr.splice(2, 4, "d", "e");// 从第2个开始，截取4个，然后添加两个"d"、"e"
console.log("spliceArr :>> ", spliceArr); // spliceArr :>>  [ 2, 3, 4, 5 ]
console.log("arr :>> ", arr); // arr :>>  [ 'b', 'c', 'd', 'e', 'a' ]

const reverseArr = arr.reverse();
console.log("reverseArr :>> ", reverseArr); // reverseArr :>>  [ 'a', 'e', 'd', 'c', 'b' ]
console.log("arr :>> ", arr); // arr :>>  [ 'a', 'e', 'd', 'c', 'b' ]
console.log("reverseArr === arr :>> ", reverseArr === arr); // reverseArr === arr :>>  true
```

### 3) 闭包

闭包(closure) 是一个函数以及其捆绑的周边环境状态的引用的组合，即闭包可以让开发者从内部函数访问外部函数的作用域

简单理解：**闭包 = 内存函数 + 引用的外层函数变量**

```js
function outer() {
    const a = 1;
    function inner() {
        console.log(a);
    }
    inner()
}
outer()
//闭包不一定要有return，但是当外部想要使用闭包的变量时，则此时需要 return
function outer() {
    let a = 10;
    return function inner() {
        console.log(a);
    }
}
const fn = outer();
fn();

//普通函数，统计函数调用次数
let i = 0;
function fn() {
    i++;
    console.log(`函数调用了${i}次`)
}
fn()//函数调用了1次
fn()//函数调用了2次
let i = 1000;
fn()//函数调用了1001次
// 因为i是全局变量所以会被篡改。

//使用闭包可以实现变量私有化
function count() {
    let i = 0;
    function fn(){
        i++;
        console.log(`函数调用了${i}次`)
    }
    return fn;
}
const fun = count();
fun()//函数调用了1次
fun()//函数调用了2次
let i = 1000;
fun()//函数调用了3次
// 使用闭包 让i变成私有变量，外面可以使用但不能修改
```

```js
function outer() {
    var num = 0; //共享的num 
    function inner() {
        num++;//内部函数中调用外部函数的变量num并执行++操作
        console.log(num);
    }
    return inner;//返回的inner 将同时保留了num所在的作用域(闭包)
}

var f1 = outer(); // f1 相当于inner + 共享的num，每次调用f1()  num都不会被销毁
f1();//1
f1();//2
var f2 = outer();
f2();//1
f2();//2

// 此处是一个闭包，闭包变量是num，内部函数inner可以访问外部函数outer中的num变量，每次调用外部函数时，都会开辟相应的内存空间，闭包变量num会保存在该内存空间中，直到该外部函数的内存空间被销毁。上述代码中调用外部函数outer时开辟了一个内存空间，变量num也保存在该内存空间中，因此两次调用f1() 结果为1,2;当f2()再此调用函数outer()时，又会重新开辟一个内存空间。所以两次调用f2() 结果也为1,2

function init() {
    var name = "JJLin";//name是一个被init创建的局部变量
    function displayName() {
        //displayName() 是内部函数，一个闭包
        console.log(name);//使用了父函数中声明的变量
    }
    displayName();
}
init();
//init()创建了一个局部变量name和一个名为 displayName() 的函数。
//displayName() 是定义在 init() 里的内部函数，并且仅在 init() 函数体内可用。
//请注意，displayName() 没有自己的局部变量。然而，因为它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。
```

闭包是作用域应用的特殊场景。js中常见的作用域包含全局作用域、函数作用域、块级作用域。要知道**js中自由变量的查找是函数定义的地方，向上级作用域查找，不是在执行的地方。**

#### 常见的闭包使用有两种场景：一种是函数作为参数被传递；一种是函数作为返回值被返回。

```js
// 函数作为返回值
function create() {
    let a = 100;
    return function() {
        console.log(a)
    }
}

const fn = create();
const a = 200;
fn();// 100
// 当执行fn()时，内部函数会尝试访问变量a。根据JavaScript的作用域链规则，内部函数会先在自己的作用域中查找变量a,如果找不到，则会继续向上级作用域查找。在此例子中，内部函数在自己的作用域中找不到变量a,但它成功地在外部函数create的作用域中找到了变量a，其值为100。因此，执行 fn() 后会输出 100。


// 函数作为参数被传递
function print(fb) {
    const b = 200;
    fb();
}
const b = 100;
function fb(){
    console.log(b)
}
print(fb);//100;
// 由于JavaScript中存在作用域链的概念，内部函数可以访问外部函数的变量。在这个例子中，fb函数在其作用域中找不到变量b，因此会继续向上一级作用域寻找，最终找到了全局作用域中的变量b,其值为100。因此，执行 print(fb) 后会输出 100。
```

```js
//假如，我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其他元素（例如header）的字号：

function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + 'px';
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);

document.getElementById('size-12').onclick = size12;
document.getElementById('size-14').onclick = size14;
document.getElementById('size-16').onclick = size16;
```

#### 闭包实现模块化和私有变量

使用闭包可以实现模块化，将一些相关的函数和变量封装在一个函数中，并返回一个公共接口。这样就可以防止这些函数和变量被其他代码意外修改，提高了代码的安全性和可维护性。
在 JavaScript 中，没有原生的私有变量机制，但是可以通过闭包实现。将一个变量定义在函数内部，然后在函数返回的闭包中使用这个变量，这个变量就成为了私有变量，只能被闭包内的函数访问。

```js
let counterModule = (function () {
    let count = 0;
    function increment() {
        count++;
        console.log('Count:', count);
    }

    function decrement() {
        count--;
        console.log('Count:', count);
    }

    return {
        increment,
        decrement
    };
})();

counterModule.increment(); // 输出：Count: 1
counterModule.increment(); // 输出：Count: 2
counterModule.decrement(); // 输出：Count: 1

counterModule = null; // 不使用闭包时，手动清除

//在上面的示例中，我们使用了立即执行函数（IIFE）来创建一个闭包，并且在闭包内部定义了两个函数 increment() 和 decrement()，用于对一个私有变量 count 进行增加和减少操作。然后我们返回一个包含这两个函数的对象，这样就可以通过该对象对外提供这些方法，从而实现模块化。

//通过使用闭包，count 变量被定义在 createCounter() 函数内部，外部代码无法直接访问它，从而实现了私有变量的效果。我们可以将 count 变量隐藏在闭包内部，防止外部代码对其进行修改。这样可以有效地避免命名冲突和数据污染等问题，同时也可以提高代码的可维护性和安全性。
```

#### 闭包的缺点

闭包的缺点主要有两个：

1. 内存泄漏：由于闭包中的函数引用了外部函数的变量，而外部函数的作用域在函数执行结束后并不会被销毁，这就导致了闭包函数中的变量也无法被销毁，从而占用了内存空间。如果闭包被滥用，可能会导致内存泄漏的问题。
2. 性能问题：闭包中的函数访问外部函数的变量需要通过作用域链来查找，而作用域链的长度决定了查找的速度。如果闭包层数较深，作用域链就会很长，从而影响了函数的执行效率。

#### 解决闭包的措施

1. 及时释放闭包：如果不再需要使用闭包，可以手动将其赋值为 null，从而释放闭包中占用的内存空间。
2. 减少闭包层数：尽量减少闭包层数，避免作用域链过长，从而提高函数的执行效率。
3. 使用立即执行函数：可以使用立即执行函数来避免闭包的内存泄漏问题。由于立即执行函数在执行结束后会被立即销毁，因此其中的变量也会被释放。
4. 使用模块化编程：可以使用模块化编程来避免闭包的性能问题。在模块化编程中，每个模块都是一个独立的作用域，不会对全局作用域造成影响，从而避免了作用域链过长的问题。

```js
function foo() {
    let count = 0;
    return function () {
        return ++count;
    }
}

let counter = foo();//创建闭包

console.log(counter());//1
console.log(counter());//2
console.log(counter());//3

counter = null; // 释放闭包
```

### 4) 实现一个类似关键字new功能的函数

在js中new关键字主要做了：首先创建一个空对象，这个对象会作为执行new构造函数之后返回的对象实例，将创建的空对象原型（`__proto__`）指向构造函数的prototype属性，同时将这个空对象赋值给构造函数内部的this，并执行构造函数逻辑，根据构造函数的执行逻辑，返回初始创建的对象或构造函数的显示返回值。

```js
function newFn(...args) {
    const constructor = args.shift();
    const obj = Object.create(constructor.prototype);
    const result = constructor.apply(obj, args);
    return typeof result === "object" && result !== null ? result : obj;
}
function Person(name) {
    this.name = name;
}

const p = newFn(Person, "JOM");
console.log( p.name); //   JOM
```

### 5) 如何实现继承（原型和原型链）

使用class语法，用extends进行继承，或直接改变对象的`__proto__`指向。

```js
class Car {
    constructor(brand) {
        this.band = band;
    }
    showBrand() {
         console.log("the brand of car :>> ", this.brand);
    }
}

// js中使用关键字extends可以创建一个类，该类继承了另一个类的属性和方法。在下例子中，ElectricCar是一个类，它通过extends Car 继承了Car 类的属性和方法。这意味着ElectricCar类拥有了Car类的所有特性，并且可以在此基础上进行扩展和自定义。
class ElectricCar extends Car {
    constructor(brand, duration) {
        super(brand);
        this.duration = duration;
    }
    showDuratino() {
         console.log(`duration of this ${this.brand} ElectricCar :>> `, this.duration);
    }
}

ElectricCar.prototype.showOriginator = function (originator) {
    console.log(`originator of this ElectricCar :>> `, originator);
}

const tesla = new ElectricCar("tesla","600km");
tesla.showBrand(); // the brand of car :>>  tesla
tesla.showDuration(); // duration of this tesla ElectricCar :>>  600km
console.log("tesla instanceof Car :>> ", tesla instanceof Car); // tesla instanceof Car :>>  true
console.log("tesla instanceof ElectricCar :>> ", tesla instanceof ElectricCar); // tesla instanceof ElectricCar :>>  true
console.log("tesla.__proto__ :>> ", tesla.__proto__); // tesla.__proto__ :>>  Car {}
console.log("ElectricCar.prototype === tesla.__proto__  :>> ", ElectricCar.prototype === tesla.__proto__); // ElectricCar.prototype === tesla.__proto__  :>>  true
tesla.showOriginator("Mask"); // originator of this  ElectricCar :>>  Mask

const bydCar = {
  brand: "比亚迪",
  duration: "666km",
};
bydCar.__proto__ = ElectricCar.prototype;

bydCar.showBrand(); //the brand of car :>>  比亚迪
bydCar.showDuration(); // duration of this 比亚迪 ElectricCar :>>  666km
```

### 6) 箭头函数和普通函数有什么区别

箭头函数不会创建自身的this，只会从上一级继承this，箭头函数的this在定义的时候就已经确认了，之后不会改变。同时箭头函数无法作为构造函数使用，没有自身的prototype，也没有arguments。

```js
this.id = "global";

console.log("this.id :>> ", this.id); // this.id :>>  global

function normalFun() {
    return this.id;
}

const arrowFun = () =>{
    return this.id;
};

const newNormal = new normalFun();
console.log("newNormal :>> ", newNormal); // newNormal :>>  normalFun {}
try{
    const newArr = new arrowFun();
} catch (error) {
    console.log("error :>> ", error); // error :>>  TypeError: arrowFun is not a constructor
// 出错原因：arrowFun不是一个构造函数，因此无法使用new关键字创建其实例。在js中箭头函数使用箭头(=>)语法定义的函数，它具有一些特殊行为和限制。与普通函数不同，箭头函数没有自己的this绑定。相反，它使用词法作用域中的this值，即它继承自包含它的代码块上下文。相反，普通函数具有自己的this绑定，可以通过new关键字进行实例化。normalFun是一个普通函数，可以使用new关键字创建它的实例。
}
```

### 7) 迭代器(iterator)接口和生成器(generator)函数的关系

任意一个对象实现了遵守迭代器协议的[Symbol.iterator]方法，那么该对象就可以调用[Symbol.iterator]返回一个遍历器对象。生成器函数就是遍历器生成函数，故可以把generator赋值给对象的[Symbol.iterator]属性，从而使该对象具有迭代器接口。

```js
class ClassRoom {
    constructor(address, name, students) {
        this.address = address;
        this.name = name;
        this.students = students;
    }
    entry(student) {
        this.students.push(student);
    }
    
    *[Symbol.iterator]() {
        yield* this.students;
    }
}
```

### 8) 浏览器的事件循环机制

任务队列：存放宏任务

微任务队列：存入微任务

执行栈：存储同步任务

1. JS是单线程，防止代码阻塞，我们把代码（任务）分为：同步和异步
2. 同步代码给js引擎执行，异步代码交给宿主环境
3. 同步代码放入执行栈中，异步代码等待时机成熟 (比如定时器完成后) 送入任务队列排队
4. 执行栈执行完毕，会去任务队列看是否有异步任务，有就送到执行栈执行，反复循环查看执行，这个过程是**事件循环(eventloop)**

​	JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

**总方针是先同步再异步，异步中先微任务，在宏任务。**

###### 重点：

​	**同步代码**：**立即**放入**js引擎**(js主程序)执行，并**原地等待**结果

​	**异步代码**：先放入**宿主环境**(浏览器/node)，不必原地等待结果，并**不阻塞**主线程继续往下执行，异步结果在**将来执行**

​	异步代码又分为 宏任务 和 微任务

​		宏任务由宿主(浏览器、Node)发起、微任务由js引擎发起

​		**Promise本身同步，then/catch的回调函数是异步的**

- 常见的同步代码：console.log(1)
- 常见的异步代码：setTimeout()、setInterval()、Ajax、Fetch、事件绑定
- 常见的微任务：Promise.then/catch、Async/await、queuMicrotask等。
- 常见宏任务：script（js整体代码）、ajax、setTimeout、setInterval、IO操作、UI交互、postMessage等。

故 事件循环可以理解为是一个桥梁，连接着应用程序的js和系统调用之间的通道。其过程为：

1. 执行一个宏任务（一般为一段script），若没有可选的宏任务，就直接处理微任务。
2. 执行中遇到微任务，就将其添加到微任务队列中。
3. 执行中遇到宏任务，就将其提交到宏任务队列中。
4. 执行完成当前执行的宏任务(<scritpt>标签就是一个宏任务)后，去查询当前有无需要执行的微任务，就有执行。
5. 检查渲染，若需要渲染，浏览器执行渲染任务。
6. 渲染完毕后，JS线程会去执行下一个宏任务。。。（如此循环）

```js
console.log("script start");
const promiseA = new Promise((resolve, reject) =>{
    console.log("init promiseA");
    resolve("promiseA")
})

const promiseB = new Promise((resolve,reject) =>{
    console.log("init promiseB");
    resolve("promiseB")
});
setTimeout(()=>{
    console.log("setTimeout run");
    promiseB.then(res =>{
       console.log("promiseB res :>> ", res);
    });
    console.log("setTimeout end");
},500)

promiseA.then(res =>{
   console.log("promiseA res :>> ", res);
})

queueMicrotask(()=> {
    console.log("queue Microtask run");
})
console.log("script end");

// script start
// init promiseA
// init promiseB
// script end
// promiseA res :>>  promiseA
// queue Microtask run
// setTimeout run
// setTimeout end
// promiseB res :>>  promiseB
```

### 9) 浏览器渲染页面的过程

首先输入一个网址，浏览器会向服务器发起DNS请求，得到对应的IP地址（会被缓存一段时间，后续访问就不用再去向服务器查询）。之后会进行tcp三次握手与服务器建立连接，连接建立后，浏览器会代表用户发送一个初始的get请求，通常是请求一个html文件。服务器收到对应请求后，会根据相关的响应头和html内容进行回复。

一旦浏览器拿到了数据，就会开始解析信息，这个过程中，浏览器会根据html文件去构建DOM树，当遇到一些阻塞资源时（如同步加载的script标签）会去加载阻塞资源而停止当前DOM树构建（所以能够异步的或延迟加载的就尽量异步或延迟，同时页面的脚步还是越少越好）。在构建DOM树时，浏览器的主线程被占据着，不过浏览器的预加载扫描器会去请求高优先级的资源（如css、js、字体），预加载扫描器很好的优化了阻塞问题。接下来浏览器会处理css生成的css DOM树，将css规则转换为可以理解和使用的样式映射，这个过程非常快（通常小于一次DNS查询所需时间）。有了DOM树和CSS DOM树，浏览器会将其组合生成一个Render树，计算样式或渲染树会从DOM的根节点开始构建，遍历每一个可见节点（将相关样式匹配到每一个可见节点，并根据CSS级联去的每个节点的计算样式）。接下来开始布局，该过程（依旧是从根节点开始）会确定所有节点的宽高和位置，最后通过渲染器将其在页面上绘制。绘制完成了，并不代表交互也生效了，因为主线程可能还无法抽出时间去处理滚动、触摸等交互，要等到js加载完成，同时主线程空闲了整个页面才是正常可用的状态。

### 10) 性能优化

#### 什么情况下会重绘和回流，常见的改善方案

浏览器请求到对应页面资源的时候，会将html解析成DOM，把css解析成css dom，然后将dom和css DOM合并就产生了Render Tree。在有了渲染树之后，浏览器会根据流式布局模型来计算它们在页面上的大小和位置，最后将节点绘制在页面上。

那么当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变，浏览器就会重新渲染页面，这个就是**浏览器的回流**。常见的回流操作有：页面的首次渲染、浏览器窗口尺寸改变、部分元素尺寸或位置变化、添加或删除可见的DOM、激活伪类、查询某些属性或调用方法（各种宽高的获取，滚动方法的执行等）

当页面中的元素样式改变不影响它在文档流的位置时（如color、background-color等），浏览器对应元素的样式，这个就是**重绘**。

可见：**回流必将导致重绘，重绘不一定会引起回流。回流比重绘的代价更高。**

#### 常见的改善方案：防抖、节流

- 在进行频繁操作时，使用防抖和节流来控制调用频率。（防抖和节流都是用来控制某个函数在一定时间内的触发次数.）

- 避免频繁操作DOM，可以利用DocumentFragment，来进行对应的DOM操作，将最后的结果添加到文档中。

- 灵活使用display：none属性，操作结束后将其显示出来，因为在display的属性为none的元素上进行的DOM操作不会引发回流和重绘

- 获取各种会引起重绘/回流的属性，尽量将其缓存起来，不要频繁的去获取。

- 对复杂动画采用决定定位，使其脱离文档流，否则它会频繁的引起父元素及其后续元素的回流。

#### 一次请求大量数据怎么优化，数据多导致渲染慢怎么优化

大量数据，应该采用异步的方式来接收，对数据进行一个分片处理，可以拆分成一个个的小单元数据，通过自定义的属性进行关联。这样数据分片完成。接下来渲染，由于大量数据，如果是长列表的话，这里就可以使用虚拟列表（当前页面需要渲染的数据拿到进行渲染，然后对前面一段范围以及后面一段范围，监听对应的滚动数据来切换需要渲染的数据，这样始终要渲染的就是三部分）。当然还有别的渲染情况，比如echarts图标大量点位数据优化等。

1. 分页加载：将数据分成多个较小的块进行加载，而不是一次性加载所有数据。通过分页加载，可以减少单次请求的数据量，从而减轻服务器和客户端的负担，提高渲染速度。
2. 延迟加载：只在需要时加载数据，而不是在初始加载时一次性加载所有数据。例如，在滚动到页面底部时才加载下一页的数据，或者在用户点击"加载更多"按钮时才进行数据加载。这样可以避免一次性加载大量数据，提高页面的响应速度。
3. 数据压缩和缓存：对传输的数据进行压缩，以减小数据的大小，从而减少网络传输时间。另外，使用适当的缓存机制，如浏览器缓存或缓存服务器，可以减少对服务器的请求次数，提高数据获取的速度。
4. 后端优化：在服务器端进行性能优化，如使用合适的数据库索引、优化查询语句、增加服务器资源等，以加快数据的检索和传输速度。
5. 前端优化：在前端代码中使用合适的技术和工具来优化数据的渲染速度。例如，使用虚拟滚动（Virtual Scrolling）或无限滚动（Infinite Scrolling）来优化大量数据的展示，只渲染可见区域的数据，而不是全部数据。
6. 数据预处理：如果可能的话，在服务器端对数据进行处理和过滤，以减少传输到前端的数据量。只传输前端需要的数据，可以减少不必要的网络传输和前端渲染的工作量。
7. 异步加载：使用异步加载技术，如AJAX或Fetch API，在后台获取数据的同时，不阻塞页面的加载和渲染。这样可以提高用户体验，让用户能够更快地与页面进行交互。

### 11) 防抖和节流

|              | 防抖                                                         | 节流                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 含义         | 单位时间内，频繁触发事件，只执行最后一次                     | 单位时间内，频繁触发事件，只执行一次                         |
| 举例         | 设定1000毫秒定时器，当触发事件了，它会在1000毫秒之后执行，但是在还剩500毫秒的时候又触发了事件，那就会重新开始1000毫秒后执行。 | 设定1000毫秒执行，如果在1000毫秒内触发多次，也只在1000毫秒后执行一次。 |
| 代码实现思路 | 利用定时器，每次触发先清掉以前的定时器(**从新开始**)         | 利用定时器，等定时器执行完毕，才开启定时器(**不要打断**)     |
| 应用场景     | 英雄回城；搜索框搜索输入；登录、短信验证等按钮避免用户点击太快，发行多次请求；文本编辑器实时保存等。 | 英雄技能冷却；快速点击；鼠标滑动；监听滚动事件；下拉加载。等 |

```js
//防抖 - 单位时间内，频繁触发事件，只执行最后一次，英雄联盟回城
//<input type="text" class="input">
<script>
    let timer = null;
    document.querySelector('.input').onkeyup = function() {
        //防抖
        //// 首次执行timer是null,后续执行都需要先清除一下定时器，从新开始
        if(timer !== null) {
            clearTimeout(timer)
        }
        // 执行一次之后timer会变成1，后续++
        timer = setTimeout(()=>{
            console.log("防抖");
        },1000)
    }
</script>
```

```js
// 节流 - 单位时间内，频繁触发事件，只执行一次，英雄联盟技能冷却
//<div class="input"></div>
<script>
    let timer = null;
    document.querySelector('.input').onmouseover = function() {
        // 节流
        if(timer !== null) {
            return
        }
        timer = setTimeout(()=>{
            console.log("我是节流");
            timer = null;
        },100)
    }
</script>
```

### 12) 浅拷贝和深拷贝

#### 浅拷贝

​	含义：把数组/对象中**第一层**的值，复制到新的数组/对象中的过程

​	使用场景：修改数组/对象，会影响另一个数组/对象时，想砍断它们的联系时使用

​	如何实现：for / for...in / 扩展运算符

```js
let a = 100;
let b = a;
a = 50;
console.log(b);//100
/*
   分析过程：定义了一个变量a，并赋值为100，
            声明一个变量b，把a里面的值赋予了a，则a=100;
            给a再次赋值50，此时a变为50；
            b未发生改变还是100
*/ 

let arr = ["小黑","小白"];
let brr = arr;
arr.push("小王");
console.log(brr);//['小黑', '小白', '小王']
/*
   分析过程：
        定义了一个变量arr，并赋值数组为 ["小黑","小白"]，当新定义一个数组/对象时，它首先会到堆内存中申请一块内存空间，每一块内存空间都有一个内存地址(0x00)，在内存空间里面会保存数组,所以arr里面装的就是内存地址，此内存地址指向堆内存中内存空间的真正数据

        声明一个变量brr，把arr里面的值赋予了arr，则brr里面装了和arr一样的内存地址(0x00);也指向堆内存中内存空间的真正数据

        当给arr指向的堆内存中添加一个新数据"小王"时，因为arr和brr指向同一个地址，所以brr也会变成['小黑', '小白', '小王']
*/ 

// let obj = {

//     name:'小李',
//     age:18
// }
// let obj2 = obj;
// obj.name = '小刘';
// console.log(obj2.name);//小刘
// 分析过程与数组分析过程一致，都是指向同一个内存地址

//1.for in 浅拷贝
let obj = {
    name:'小李',
    age:18
}
let obj2 = {};
for (const key in obj) {
    obj2[key] = obj[key]
}
obj.name = '小刘';
console.log(obj2.name);//小李
/*
只要新建一个数组对象就在堆内存中申请一块新的地址
  分析过程：
     声明了一个变量obj，则在堆内存中申请一个空间保存obj对象，并把内存地址(0x00)赋值给了obj，obj指向 0x00

     声明了一个obj2，则在堆内存中申请另一个空间保存obj2的空对象，并把内存地址(0x01)赋值给了obj2，obj2指向0x01

     使用for in 将obj里面的属性和值都复制给obj2里面

     修改了obj里面的name为'小刘'，因为obj和obj2指向不同，则obj2里面的name不会受影响
*/ 

//2.扩展运算符... 浅拷贝
let obj3 = {
    name:'小米',
    age:24
}

let obj4 = {...obj3}
console.log(obj4);//{name: '小米', age: 24}

// 3.Object.assign合并
let obj5 = {
    name:'小菜',
    age:27
}

let obj6 = Object.assign({},obj5);
console.log(obj6);//{name: '小菜', age: 27}
```

**浅拷贝的问题**：只能拷贝第一层的值，第二层的值还是相互引用

​	注意：只要看到一个新的对象或数组，都会在堆内存中开辟一个新的空间

```js
let arr = ["小刘","小明",["小花"]];
let brr = [...arr];
console.log(brr);//["小刘","小明",["小花"]]
arr[2].push("小黑")
console.log(brr);//["小刘","小明",["小花","小黑"]]

/*
 分析过程：
    arr里面是一个二维数组，每遇到一个[]都要开辟一个新的内存地址
    
    let arr = ["小刘","小明",["小花"]];相当于在堆内存中开辟了一个内存地址，0x001,存放着["小刘","小明",0x002],0x002存放着["小花"]，arr里面一层数组里面只放着小花的内存地址，真正的值在新的内存地址0x002放着

    所以拷贝出来的brr里面小花也是放着0x002的内存地址，arr和brr里面的都指向同一个内存地址，所以当arr[2].push("小黑")时，brr里面的值也会发生变化
*/ 
```

#### 深拷贝

​	含义：把数组/对象中**所有层**的值，复制到新的数组/对象中的过程

​	如何实现：创建新数组/对象，判断是基础数据类型则直接赋值，是对象类型(包括数组)则递归调用函数，继续创建判断

```js
let obj = {
    name: '小明',
    age: 18,
    grade: [100, 80],
    family: {
        fName: "王"
    }
}
// 深拷贝obj里面的所有值
let newObj = {}

function deepClone(newObj, obj) {
    for (const key in obj) {//key是：name、age、grade、family
        let value = obj[key];//obj[key] 就是obj的每一项的value 即：小明、18、[100,80]、{fName:"王"}
        if (value instanceof Array) {//如果拿到的值是数组
            newObj[key] = [];//{name:"小明",age：18,grade:[]}
            deepClone(newObj[key], value)
        } else if (value instanceof Object) {//如果拿到的值是对象
            newObj[key] = {};//{name:"小明",age：18,grade:[],family:{}}
            deepClone(newObj[key], value)
        }else{//拿到的数据就是基本数据类型，直接复制就可
            newObj[key] = value;
        }
    }
}

/*
分析过程：
  deepClone()方法用于克隆obj里面的所有数据给newObj这个空对象，
  首先循环obj，key即是obj的属性名，obj[key]即为obj的属性值,
  拿到obj中的每一项的值用value接住,
  然后判断value是否为数组/对象，引用数据类型还需要递归拷贝一次，当value拿到obj中的数组时，newObj[key] = [];意思为新数组newObj里面也添加一个名为grade的空数组即{name:"小明",age：18,grade:[]}，然后拿newObj[key] = []空数组 和 obj里面的数据[100, 80]继续递归，将[100, 80]复制到newObj的grade中即完成了对数组的拷贝
  对象拷贝和数组同理，只不过换成对象而已
*/ 
```

####  手写深拷贝

```js
function deepCopy(obj) {
    if (typeof obj !== 'object' || obj === null) {
        // 如果传人的参数不是对象或 是null，则直接返回该参数
        return obj;
    }
    
    // 根据obj的类型创建一个新的空对象或数组，必须先数组后对象，因为对象是数组的父集
    // Array.isArray() 判断是否为数组
    const newObj = Array.isArray(obj) ? [] : {};
    
    // 遍历obj的属性
    for (let key in obj) {
        // 递归调用deepCopy函数，对每个属性进行深拷贝
        newObj[key] = deepCopy(obj[key]);
    }
    
    return newObj;
}
```

使用该函数进行深拷贝时，它会递归遍历对象的所有属性，并创建一个完全独立的副本。这样可以确保修改副本的属性不会影响原始对象。

示例：

```js
const obj = {
    name : 'JJLin',
    age:42,
    address :{
        city: 'LA',
        country:'USA'
    }
}

const copy = deepCopy(obj);
console.log(copy);
// 输出: { name: 'John', age: 30, address: { city: 'LA', country: 'USA' } }

//修改副本的属性
copy.name = 'JAYChou';
copy.address.city = 'New York';

console.log(copy);
// 输出: { name: 'JAYChou', age: 42, address: { city: 'New York', country: 'USA' } }

console.log(obj);
// 输出: { name: 'JJLin', age: 42, address: { city: 'LA', country: 'USA' } }
```

### 13）手写快速排序

```js
function quickSort(arr) {
    if(arr.length <= 1){
        return arr
    }
    
    const pivotIndex = Math.floor(arr.length / 2);
    const pivot = arr[pivotIndex];
    const left = [];
    const right = [];
    
    for (let i = 0; i < arr.length; i++) {
        if (i === pivotIndex) {
            continue;
        }
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return [...quickSort(left), pivot, ...quickSort(right)];
}
//这是递归实现快速排序算法。它选择数组中间的元素作为基准值（pivot），然后将数组分为两部分：小于基准值的元素放在左边，大于基准值的元素放在右边。然后，对左右两个部分分别进行递归排序，最后将结果合并起来。
```

示例

```js
const arr = [5,2,9,1,7,6,3];
const sortedArr = quickSort(arr);
console.log(sortedArr);  // 输出: [1, 2, 3, 5, 6, 7, 9]
```

这只是一个简单的快速排序算法示例，可能并不适用于所有情况。在实际应用中，可能需要考虑性能优化、处理重复元素等问题。同时，还要注意快速排序的时间复杂度为O(n log n)，在处理大规模数据时可能需要考虑性能问题。

### 14）输入为两个一维数组，将这两个数组合并，去重，不要求排序，返回一维数组

```js
function mergeAndDeduplicateArrays(arr1,arr2) {
    const mergedArray = arr1.concat(arr2);
    const deduplicatedArray = [...new Set(mergedArray)];
    return deduplicatedArray;
}
```

这个函数将两个数组`arr1`和`arr2`合并成一个新的数组`mergedArray`，然后使用ES6的Set数据结构对新数组进行去重操作，得到去重后的数组`deduplicatedArray`。最后，将去重后的数组作为结果返回。

你可以调用这个函数来合并和去重两个数组，例如：

```js
const arr1 = [1, 2, 3];
const arr2 = [2, 3, 4, 5];
const mergedAndDeduplicatedArray = mergeAndDeduplicateArrays(arr1, arr2);
console.log(mergedAndDeduplicatedArray);  // 输出: [1, 2, 3, 4, 5]
```

### 15）JS中call、apply、bind的区别

​	在JavaScript中，call()、apply()、bind()是用于改变函数执行上下文(即this指向)的方法。

**call()** 方法允许以指定的this值和单独给出的参数列表来调用函数，语法 `funcion.call(thisArg,arg1,arg2,...)` ，第一个参数表示this要指向的对象，其余参数表示调用函数需要传入的参数，返回调用函数的返回结果，属于立即执行函数；

你可以用一个对象来替换当前对象，然后在新对象的环境中调用函数

```js
function sayHello() {
    console.log('Hello ' + this.name);
}

let person = {name:'JJLin'};
sayHello.call(person) //HelloJJLin
```

call()应用

```js
function Person(name) {
    this.name = name;
    this.say = function () {
        console.log("我是" + this.name);
    }
}

function Student(studentNo,name) {
    this.studentNo = studentNo;
    // 此this指向Student
    // 通过改变this指向，使Person里的this指向Student
    // 从而实现使用Student就拥有Person里的name属性以及say方法，即实现继承
    // 具体来说，下述代码会执行Person函数，并将当前Student函数中的this指向传递给Person函数，同时还会传入name参数。这样一来Person函数中使用this.name = name的赋值操作，实际上会将name属性添加到Student实例对象上，从而实现了对Person中属性的继承。
    // 这种继承方式称为借用构造函数，它允许一个构造函数在另一个构造函数内部被调用，并将当前对象作为新构造函数的 this。
    Person.call(this,name)
}

// 实例化Student
let student1 = new Student("20240104","小白");
student1.say();//我是小白
console.log("姓名："+student1.name+",学号："+student1.studentNo);//姓名：小白,学号：20240104
```

**apply()** 方法与call()类似，区别在于它接收两个参数，第二个参数是一个参数数组而不是一些列参数，语法 `function.apply(thisArg, [argsArr])`，第一个参数表示this要指向的对象，第二个参数表示调用函数需要传入的参数所组成的数组，返回调用函数的返回结果，属于立即执行函数；

```js
function intr(greeting,farewell) {
    console.log(greeting + ',' + this.name);//Hello,JJLin
    console.log(farewell + ',' + this.name);//Goodbye,JJLin
}
let person = {name:'JJLin'}

intr.apply(person,['Hello', 'Goodbye'])
```

```js
// 此处若用let声明，则第一个调用函数输出undefined
// 此处let声明的变量虽然也是全局变量但其不会成为全局对象window的属性，因为ES6 标准中，let 声明的变量不会被添加到全局对象上，从而避免了全局变量的污染和不可预测的行为。故say()直接调用时为undefined

var word = '我是window';
function say(params1,params2) {
    console.log(params1+" " + params2 +"," + this.word);
}

let obj = {
    word: "我是obj"
}
let newObj = {
    word:"我是newObj"
}

say("Hi","friend")//Hi friend,我是window  //let 声明 则输出：Hi friend,undefined
say.call(obj,"Hi","friend")//Hi friend,我是obj    this指向obj
say.apply(newObj,["Hi","friend"]) //Hi friend,我是newObj   this指向newObj
```

**bind()** 接收一个及其以上的参数，和call()一致，但bind方法创建一个新的函数，当被调用时，将其this值设为提供的值，然后再调用原函数。bind() 不会立即执行，而是返回一个新的函数,而不是调用新函数的返回结果。

```js
let person = {name:'JJLin'};
function sayHi() {
    console.log('Hi ' + this.name);
}
let sayHiAgain = sayHi.bind(person);
sayHiAgain()//Hi JJLin
```

```js
var obj = {};
function test() {
    console.log(this === obj);
}
test()// false

var testObj = test.bind(obj);
testObj()//true
```

```js
var word = "我是window";
function say(params1, params2) {
    console.log(params1 + " " + params2 + "，" + this.word)
}
let Obj1 = {
    word: "我是newObj1"
}
let Obj2 = {
    word: "我是newObj2"
}
//返回一个新的函数
let newFunc = say.bind(Obj1, "hello", "friend");
newFunc()   //hello friend，我是newObj1

//可将其改为立即执行函数，此时返回和call()，apply（）相同
say.bind(Obj2, "hello", "friend")();   //hello friend，我是newObj2
```

区别：

- 当我们使用一个函数需要改变this指向时才会用到 call、apply、bind
- 如果传递的参数不多，则使用 `fn.call(obj,arg1,arg2,...)`
- 如果传递的参数很多，则可以使用数组整理好参数，调用 `fn.apply(obj,[arg1,arg2,...])`
- 如果想生成一个新对象长期绑定某个函数供某个对象使用，则使用const newFn = fn.bind(this.obj) newFn(arg1,arg2,...)

### 16）Object.key和Object.values用法

**`Object.keys()`** 静态方法返回一个由给定对象自身的可枚举的字符串键 **属性名** 组成的数组。

**`Object.values()`** 静态方法返回一个给定对象的自有可枚举字符串键 **属性值 **组成的数组。

```js
const object = {
  a: 'somestring',
  b: 42,
  c: false,
};
console.log(Object.keys(object));//['a', 'b', 'c']

console.log(Object.values(object));//['somestring', 42, false]
```

### 17）this 指向问题

setTimeout中的this指向全局,可以使用箭头函数解决此问题，











































