[TOC]
## 1.Html5和CSS3

### 常见的水平垂直居中实现方案

- 最简单的方案 flex布局

  ```css
  .father {
      display:flex;
      justify-content:center;
      align-items: center;
  }
  .son {
      ...
  }
  ```

- 绝对定位配合margin:auto，实现

  ```css
  .father {
      position: relative;
  }
  .son {
      position: absolute;
      top:0;
      left:0;
      bottom: 0;
      right:0;
      margin: auto;
  }
  ```

- 绝对定位配合transform实现

  ```css
  .father {
      position: relative;
  }
  .son {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%)
  }
  ```

### BFC问题

BFC：块格式上下文，是一块独立的渲染区域，内部元素不会影响外部的元素。

**flex:1;是哪些属性的缩写，对应的属性代表什么含义**

flex:1;在浏览器中查看分别是flex-grow（设置了对应元素的增长系数）、flex-shrink（指定了对应元素的收缩规则，只有在所有元素的默认宽度之和大于容器宽度时才会触发）、flex-basis（指定了对应元素在主轴上的大小）

```css
flex: 1;
  flex-grow: 1;
  flex-shrink: 1;
  flex-basis: 0%;
```

隐藏元素的属性

- display：none；
- visibility：hidden；
- opacity：0；

### position的属性

position是CSS中用来控制元素定位的属性，有以下几种取值：

1. static：默认值，元素遵循正常文档流，不会被特殊定位。
2. relative：相对定位，元素相对于其自身在文档流中的位置进行定位，通过top、right、bottom、left属性来调整位置
3. absolute：绝对定位，元素相对于其最近的一个已定位的祖先元素进行定位，如果没有已定位的祖先元素，则相对于<html>元素。通过top、right、bottom、left属性来设置位置。
4. fixed：固定定位，元素相对于浏览器窗口进行定位，即使页面滚动，元素也会保持固定位置。也是通过top、right、bottom、left属性来设置位置。
5. sticky：粘性定位，元素在跨越特定阈值前为相对定位，之后为固定定位。通过top、right、bottom、left属性来设置固定位置的阈值。

`position: sticky` 和 `position: fixed` 都是用来实现元素的固定定位，但它们之间有一些重要的区别：

`position: fixed`：

1. 元素固定在浏览器窗口中的某个位置，即使页面滚动，元素也会保持在固定位置。
2. 元素的定位参考是视口（viewport），而不是任何父元素。
3. 在移动端设备和一些旧的浏览器上可能会出现性能问题，因为固定定位的元素需要在滚动时进行实时的重新渲染。

`position: sticky`：

1. 元素在滚动时表现为普通定位，直到它滚动到特定的位置，然后会变为固定定位，直到它的父容器结束。
2. 元素会在父容器内固定，而不是在视口中固定。
3. 具有粘性定位的元素会在滚动时表现得更加平滑，因为它只有在特定条件下才会变为固定定位元素，这有助于减少页面重绘和重新渲染的频率。

总的来说，`position: fixed` 是将元素固定在视口中的某个位置，而 `position: sticky` 则在滚动到特定位置时，会固定在父容器内部。`position: sticky` 可以提供更好的性能和使用体验，但是需要根据具体的布局需求进行选择。

```html
<style>
    .header {
        position: -webkit-sticky;
        /* Safari */
        position: sticky;
        top: 0;
        background-color: #f1f1f1;
        padding: 10px;
        margin-top: 120px;
    }

    .content {
        height: 2000px;
        /* 为了拉长内容区域 */
    }
</style>

<body>
	<div class="header">
		<p>我是一个吸顶元素</p>
	</div>
	<div class="content">
		<p>这是内容区域</p>
	</div>
</body>
```

### CSS中的颜色HSL

HSL（Hue, Saturation, Lightness）是一种颜色模型，它使用色调、饱和度和明度三个参数来表示颜色。

- **色调（Hue）**：色调是指颜色的基本颜色，比如红色、橙色、黄色、绿色、蓝色、靛色和紫色。色调用角度表示，范围从 0° 到 360°。0° 为红色，120° 为绿色，240° 为蓝色。
- **饱和度（Saturation）**：饱和度是指颜色的强度或纯度。饱和度越高，颜色越鲜艳；饱和度越低，颜色越灰暗。饱和度用百分比表示，范围从 0% 到 100%。0% 为灰色，100% 为完全饱和的颜色。
- **明度（Lightness）**：明度是指颜色的亮度或暗度。明度越高，颜色越亮；明度越低，颜色越暗。明度用百分比表示，范围从 0% 到 100%。0% 为黑色，100% 为白色。

**HSL 用法**

HSL 可以用以下方式表示：

```
hsl(色调, 饱和度, 明度)
```

例如，以下代码表示一个鲜艳的红色：

```
hsl(0, 100%, 50%)
```

以下代码表示一个暗淡的蓝色：

```
hsl(240, 50%, 25%)
```

HSL 可以用在 CSS、HTML 和 SVG 中来指定颜色。

**CSS**

```css
body {
  background-color: hsl(0, 100%, 50%);
}
```

**HTML**

```html
<div style="background-color: hsl(0, 100%, 50%);">
  Hello world!
</div>
```

**SVG**

```svg
<rect width="100" height="100" fill="hsl(0, 100%, 50%)" />
```





## 2.js相关

### 1) JS基础类型，typeof和instanceof的区别

基础类型有：boolean、string、number、null、undefined、symbol、bigint。

typeof 能识别所有的值类型，识别函数，能区分是否是引用类型。\

```js
typeof "123" ==> str        typeof 123  ==> number    typeof BigInt(9007199254740991) ==> bigint
typeof false  ==> boolean   typeof undefined ==> undefined  typeof ()=>{}  ==> function
typeof null ==> object     typeof []  ==> object      typeof  Symbol("f") ==> symbol
```

instanceof用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。

### 2) 数组的forEach和map方法有哪些区别？常用哪些方法对数组进行增、删、改

- forEach是对数组的每一个元素执行一次给定的函数。
- map是创建一个新数组，该新数组由原数组的每个元素都调用一次提供的函数返回的值。
- pop()：删除数组后面的最后一个元素，返回值为**被删除的**那个元素
- push()：将一个元素或多个元素添加到数组末尾，并返回**新的长度**。
- shift()：删除数组中的第一个元素，并返回被删除元素的值。
- unshift()：将一个或多个元素添加到数组的**开头**，并返回该数组的**新长度**。
- splice()：通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容
- reverse()：反转数组。

```js
const arr = [1,2,3,4,5,6]
arr.forEach(x => {
    x = x +1 ;
    console.log(x);
});
// x :>>  2
// x :>>  3
// x :>>  4
// x :>>  5
// x :>>  6
// x :>>  7
console.log(arr);
//[ 1, 2, 3, 4, 5, 6 ]

const mapArr = arr.map(x => {
    x = x*2;
    return x;
});
console.log("mapArr :>> ", mapArr); // [ 2, 4, 6, 8, 10, 12 ]
console.log("arr :>> ", arr); //  [ 1, 2, 3, 4, 5, 6 ]

const popArr = arr.pop();
console.log("popArr :>> ", popArr); // popArr :>>  6
console.log("arr :>> ", arr); // arr :>>  [ 1, 2, 3, 4, 5 ]

const pushArr = arr.push("a");
console.log("pushArr :>> ", pushArr); // pushArr :>>  6
console.log("arr :>> ", arr); // arr :>>  [ 1, 2, 3, 4, 5, 'a' ]

const shiftArr = arr.shift();
console.log("shiftArr :>> ", shiftArr); // shiftArr :>>  1
console.log("arr :>> ", arr); // arr :>>  [ 2, 3, 4, 5, 'a' ]

const unshiftArr = arr.unshift("b", "c");
console.log("unshiftArr :>> ", unshiftArr); // unshiftArr :>>  7
console.log("arr :>> ", arr); // arr :>>  ['b', 'c', 2,3,4,5,'a']

const spliceArr = arr.splice(2, 4, "d", "e");// 从第2个开始，截取4个，然后添加两个"d"、"e"
console.log("spliceArr :>> ", spliceArr); // spliceArr :>>  [ 2, 3, 4, 5 ]
console.log("arr :>> ", arr); // arr :>>  [ 'b', 'c', 'd', 'e', 'a' ]

const reverseArr = arr.reverse();
console.log("reverseArr :>> ", reverseArr); // reverseArr :>>  [ 'a', 'e', 'd', 'c', 'b' ]
console.log("arr :>> ", arr); // arr :>>  [ 'a', 'e', 'd', 'c', 'b' ]
console.log("reverseArr === arr :>> ", reverseArr === arr); // reverseArr === arr :>>  true
```

### 3) 闭包

闭包(closure) 是一个函数以及其捆绑的周边环境状态的引用的组合，即闭包可以让开发者从内部函数访问外部函数的作用域

简单理解：**闭包 = 内存函数 + 引用的外层函数变量**

```js
function outer() {
    const a = 1;
    function inner() {
        console.log(a);
    }
    inner()
}
outer()
//闭包不一定要有return，但是当外部想要使用闭包的变量时，则此时需要 return
function outer() {
    let a = 10;
    return function inner() {
        console.log(a);
    }
}
const fn = outer();
fn();

//普通函数，统计函数调用次数
let i = 0;
function fn() {
    i++;
    console.log(`函数调用了${i}次`)
}
fn()//函数调用了1次
fn()//函数调用了2次
let i = 1000;
fn()//函数调用了1001次
// 因为i是全局变量所以会被篡改。

//使用闭包可以实现变量私有化
function count() {
    let i = 0;
    function fn(){
        i++;
        console.log(`函数调用了${i}次`)
    }
    return fn;
}
const fun = count();
fun()//函数调用了1次
fun()//函数调用了2次
let i = 1000;
fun()//函数调用了3次
// 使用闭包 让i变成私有变量，外面可以使用但不能修改
```

```js
function outer() {
    var num = 0; //共享的num 
    function inner() {
        num++;//内部函数中调用外部函数的变量num并执行++操作
        console.log(num);
    }
    return inner;//返回的inner 将同时保留了num所在的作用域(闭包)
}

var f1 = outer(); // f1 相当于inner + 共享的num，每次调用f1()  num都不会被销毁
f1();//1
f1();//2
var f2 = outer();
f2();//1
f2();//2

// 此处是一个闭包，闭包变量是num，内部函数inner可以访问外部函数outer中的num变量，每次调用外部函数时，都会开辟相应的内存空间，闭包变量num会保存在该内存空间中，直到该外部函数的内存空间被销毁。上述代码中调用外部函数outer时开辟了一个内存空间，变量num也保存在该内存空间中，因此两次调用f1() 结果为1,2;当f2()再此调用函数outer()时，又会重新开辟一个内存空间。所以两次调用f2() 结果也为1,2

function init() {
    var name = "JJLin";//name是一个被init创建的局部变量
    function displayName() {
        //displayName() 是内部函数，一个闭包
        console.log(name);//使用了父函数中声明的变量
    }
    displayName();
}
init();
//init()创建了一个局部变量name和一个名为 displayName() 的函数。
//displayName() 是定义在 init() 里的内部函数，并且仅在 init() 函数体内可用。
//请注意，displayName() 没有自己的局部变量。然而，因为它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。
```

闭包是作用域应用的特殊场景。js中常见的作用域包含全局作用域、函数作用域、块级作用域。要知道**js中自由变量的查找是函数定义的地方，向上级作用域查找，不是在执行的地方。**

#### 常见的闭包使用有两种场景：一种是函数作为参数被传递；一种是函数作为返回值被返回。

```js
// 函数作为返回值
function create() {
    let a = 100;
    return function() {
        console.log(a)
    }
}

const fn = create();
const a = 200;
fn();// 100
// 当执行fn()时，内部函数会尝试访问变量a。根据JavaScript的作用域链规则，内部函数会先在自己的作用域中查找变量a,如果找不到，则会继续向上级作用域查找。在此例子中，内部函数在自己的作用域中找不到变量a,但它成功地在外部函数create的作用域中找到了变量a，其值为100。因此，执行 fn() 后会输出 100。


// 函数作为参数被传递
function print(fb) {
    const b = 200;
    fb();
}
const b = 100;
function fb(){
    console.log(b)
}
print(fb);//100;
// 由于JavaScript中存在作用域链的概念，内部函数可以访问外部函数的变量。在这个例子中，fb函数在其作用域中找不到变量b，因此会继续向上一级作用域寻找，最终找到了全局作用域中的变量b,其值为100。因此，执行 print(fb) 后会输出 100。
```

```js
//假如，我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其他元素（例如header）的字号：

function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + 'px';
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);

document.getElementById('size-12').onclick = size12;
document.getElementById('size-14').onclick = size14;
document.getElementById('size-16').onclick = size16;
```

#### 闭包实现模块化和私有变量

使用闭包可以实现模块化，将一些相关的函数和变量封装在一个函数中，并返回一个公共接口。这样就可以防止这些函数和变量被其他代码意外修改，提高了代码的安全性和可维护性。
在 JavaScript 中，没有原生的私有变量机制，但是可以通过闭包实现。将一个变量定义在函数内部，然后在函数返回的闭包中使用这个变量，这个变量就成为了私有变量，只能被闭包内的函数访问。

```js
let counterModule = (function () {
    let count = 0;
    function increment() {
        count++;
        console.log('Count:', count);
    }

    function decrement() {
        count--;
        console.log('Count:', count);
    }

    return {
        increment,
        decrement
    };
})();

counterModule.increment(); // 输出：Count: 1
counterModule.increment(); // 输出：Count: 2
counterModule.decrement(); // 输出：Count: 1

counterModule = null; // 不使用闭包时，手动清除

//在上面的示例中，我们使用了立即执行函数（IIFE）来创建一个闭包，并且在闭包内部定义了两个函数 increment() 和 decrement()，用于对一个私有变量 count 进行增加和减少操作。然后我们返回一个包含这两个函数的对象，这样就可以通过该对象对外提供这些方法，从而实现模块化。

//通过使用闭包，count 变量被定义在 createCounter() 函数内部，外部代码无法直接访问它，从而实现了私有变量的效果。我们可以将 count 变量隐藏在闭包内部，防止外部代码对其进行修改。这样可以有效地避免命名冲突和数据污染等问题，同时也可以提高代码的可维护性和安全性。
```

#### 闭包的缺点

闭包的缺点主要有两个：

1. 内存泄漏：由于闭包中的函数引用了外部函数的变量，而外部函数的作用域在函数执行结束后并不会被销毁，这就导致了闭包函数中的变量也无法被销毁，从而占用了内存空间。如果闭包被滥用，可能会导致内存泄漏的问题。
2. 性能问题：闭包中的函数访问外部函数的变量需要通过作用域链来查找，而作用域链的长度决定了查找的速度。如果闭包层数较深，作用域链就会很长，从而影响了函数的执行效率。

#### 解决闭包的措施

1. 及时释放闭包：如果不再需要使用闭包，可以手动将其赋值为 null，从而释放闭包中占用的内存空间。
2. 减少闭包层数：尽量减少闭包层数，避免作用域链过长，从而提高函数的执行效率。
3. 使用立即执行函数：可以使用立即执行函数来避免闭包的内存泄漏问题。由于立即执行函数在执行结束后会被立即销毁，因此其中的变量也会被释放。
4. 使用模块化编程：可以使用模块化编程来避免闭包的性能问题。在模块化编程中，每个模块都是一个独立的作用域，不会对全局作用域造成影响，从而避免了作用域链过长的问题。

```js
function foo() {
    let count = 0;
    return function () {
        return ++count;
    }
}

let counter = foo();//创建闭包

console.log(counter());//1
console.log(counter());//2
console.log(counter());//3

counter = null; // 释放闭包
```

### 4) 实现一个类似关键字new功能的函数

在js中new关键字主要做了：首先创建一个空对象，这个对象会作为执行new构造函数之后返回的对象实例，将创建的空对象原型（`__proto__`）指向构造函数的prototype属性，同时将这个空对象赋值给构造函数内部的this，并执行构造函数逻辑，根据构造函数的执行逻辑，返回初始创建的对象或构造函数的显示返回值。

```js
function newFn(...args) {
    const constructor = args.shift();
    const obj = Object.create(constructor.prototype);
    const result = constructor.apply(obj, args);
    return typeof result === "object" && result !== null ? result : obj;
}
function Person(name) {
    this.name = name;
}

const p = newFn(Person, "JOM");
console.log( p.name); //   JOM
```

### 5) 如何实现继承（原型和原型链）

使用class语法，用extends进行继承，或直接改变对象的`__proto__`指向。

```js
class Car {
    constructor(brand) {
        this.band = band;
    }
    showBrand() {
         console.log("the brand of car :>> ", this.brand);
    }
}

// js中使用关键字extends可以创建一个类，该类继承了另一个类的属性和方法。在下例子中，ElectricCar是一个类，它通过extends Car 继承了Car 类的属性和方法。这意味着ElectricCar类拥有了Car类的所有特性，并且可以在此基础上进行扩展和自定义。
class ElectricCar extends Car {
    constructor(brand, duration) {
        super(brand);
        this.duration = duration;
    }
    showDuratino() {
         console.log(`duration of this ${this.brand} ElectricCar :>> `, this.duration);
    }
}

ElectricCar.prototype.showOriginator = function (originator) {
    console.log(`originator of this ElectricCar :>> `, originator);
}

const tesla = new ElectricCar("tesla","600km");
tesla.showBrand(); // the brand of car :>>  tesla
tesla.showDuration(); // duration of this tesla ElectricCar :>>  600km
console.log("tesla instanceof Car :>> ", tesla instanceof Car); // tesla instanceof Car :>>  true
console.log("tesla instanceof ElectricCar :>> ", tesla instanceof ElectricCar); // tesla instanceof ElectricCar :>>  true
console.log("tesla.__proto__ :>> ", tesla.__proto__); // tesla.__proto__ :>>  Car {}
console.log("ElectricCar.prototype === tesla.__proto__  :>> ", ElectricCar.prototype === tesla.__proto__); // ElectricCar.prototype === tesla.__proto__  :>>  true
tesla.showOriginator("Mask"); // originator of this  ElectricCar :>>  Mask

const bydCar = {
  brand: "比亚迪",
  duration: "666km",
};
bydCar.__proto__ = ElectricCar.prototype;

bydCar.showBrand(); //the brand of car :>>  比亚迪
bydCar.showDuration(); // duration of this 比亚迪 ElectricCar :>>  666km
```

### 6) 箭头函数和普通函数有什么区别

箭头函数不会创建自身的this，只会从上一级继承this，箭头函数的this在定义的时候就已经确认了，之后不会改变。同时箭头函数无法作为构造函数使用，没有自身的prototype，也没有arguments。

```js
this.id = "global";

console.log("this.id :>> ", this.id); // this.id :>>  global

function normalFun() {
    return this.id;
}

const arrowFun = () =>{
    return this.id;
};

const newNormal = new normalFun();
console.log("newNormal :>> ", newNormal); // newNormal :>>  normalFun {}
try{
    const newArr = new arrowFun();
} catch (error) {
    console.log("error :>> ", error); // error :>>  TypeError: arrowFun is not a constructor
// 出错原因：arrowFun不是一个构造函数，因此无法使用new关键字创建其实例。在js中箭头函数使用箭头(=>)语法定义的函数，它具有一些特殊行为和限制。与普通函数不同，箭头函数没有自己的this绑定。相反，它使用词法作用域中的this值，即它继承自包含它的代码块上下文。相反，普通函数具有自己的this绑定，可以通过new关键字进行实例化。normalFun是一个普通函数，可以使用new关键字创建它的实例。
}
```

### 7) 迭代器(iterator)接口和生成器(generator)函数的关系

任意一个对象实现了遵守迭代器协议的[Symbol.iterator]方法，那么该对象就可以调用[Symbol.iterator]返回一个遍历器对象。生成器函数就是遍历器生成函数，故可以把generator赋值给对象的[Symbol.iterator]属性，从而使该对象具有迭代器接口。

```js
class ClassRoom {
    constructor(address, name, students) {
        this.address = address;
        this.name = name;
        this.students = students;
    }
    entry(student) {
        this.students.push(student);
    }
    
    *[Symbol.iterator]() {
        yield* this.students;
    }
}
```

### 8) 浏览器的事件循环机制

任务队列：存放宏任务

微任务队列：存入微任务

执行栈：存储同步任务

1. JS是单线程，防止代码阻塞，我们把代码（任务）分为：同步和异步
2. 同步代码给js引擎执行，异步代码交给宿主环境
3. 同步代码放入执行栈中，异步代码等待时机成熟 (比如定时器完成后) 送入任务队列排队
4. 执行栈执行完毕，会去任务队列看是否有异步任务，有就送到执行栈执行，反复循环查看执行，这个过程是**事件循环(eventloop)**

​	JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

**总方针是先同步再异步，异步中先微任务，在宏任务。**

#### 重点：

​	**同步代码**：**立即**放入**js引擎**(js主程序)执行，并**原地等待**结果

​	**异步代码**：先放入**宿主环境**(浏览器/node)，不必原地等待结果，并**不阻塞**主线程继续往下执行，异步结果在**将来执行**

​	异步代码又分为 宏任务 和 微任务

​		宏任务由宿主(浏览器、Node)发起、微任务由js引擎发起

​		**Promise本身同步，then/catch的回调函数是异步的**

- 常见的同步代码：console.log(1)
- 常见的异步代码：setTimeout()、setInterval()、Ajax、Fetch、事件绑定
- 常见的微任务：Promise.then/catch、Async/await、queuMicrotask等。
- 常见宏任务：script（js整体代码）、ajax、setTimeout、setInterval、IO操作、UI交互、postMessage等。

故 事件循环可以理解为是一个桥梁，连接着应用程序的js和系统调用之间的通道。其过程为：

1. 执行一个宏任务（一般为一段script），若没有可选的宏任务，就直接处理微任务。
2. 执行中遇到微任务，就将其添加到微任务队列中。
3. 执行中遇到宏任务，就将其提交到宏任务队列中。
4. 执行完成当前执行的宏任务(<scritpt>标签就是一个宏任务)后，去查询当前有无需要执行的微任务，就有执行。
5. 检查渲染，若需要渲染，浏览器执行渲染任务。
6. 渲染完毕后，JS线程会去执行下一个宏任务。。。（如此循环）

```js
console.log("script start");
const promiseA = new Promise((resolve, reject) =>{
    console.log("init promiseA");
    resolve("promiseA")
})

const promiseB = new Promise((resolve,reject) =>{
    console.log("init promiseB");
    resolve("promiseB")
});
setTimeout(()=>{
    console.log("setTimeout run");
    promiseB.then(res =>{
       console.log("promiseB res :>> ", res);
    });
    console.log("setTimeout end");
},500)

promiseA.then(res =>{
   console.log("promiseA res :>> ", res);
})

queueMicrotask(()=> {
    console.log("queue Microtask run");
})
console.log("script end");

// script start
// init promiseA
// init promiseB
// script end
// promiseA res :>>  promiseA
// queue Microtask run
// setTimeout run
// setTimeout end
// promiseB res :>>  promiseB
```

#### promise

​	promise可以被翻译成承诺、保证，promise有3种状态 成功（fulfiled）或者失败（rejected），还有一个等待状态（pending）。

```js
let promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(2000)//成功后，resolve会把成功的结果捕捉到
        //reject(2000)//失败后，reject会把失败的结果捕捉到
    }, 1000)
    console.log(1111);
})

promise.then(res => {
    console.log(res);//then第一个参数可以拿到成功的结果
}, err => {
    console.log(err);//then的第二个参数可以拿到失败的结果
})
/*打印结果：
1111
2000 (1秒之后打印)
*/
```

1. ##### then链式操作

   Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。

   then方法接收 **两个函数**作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。

   两个函数只会有一个被调用。promise的执行 结果只能是成功（fulfiled）或者失败（rejected）

   函数的返回值将被用作创建then返回的Promise对象。

   ```js
   let promise = new Promise((resolve, reject) => {
       setTimeout(() => {
           resolve(2000)
       }, 1000)
       console.log(11111);
   })
   
   promise.then(res => {
       console.log(res); //打印2000
       return res + 1000;//这个函数的返回值，返回的就是这个promise对象捕捉到的成功的值
   }).then(res => {
       console.log(res);//打印3000，上一个promise对象return的值
   })
   /*
   打印顺序
   11111
   2000
   3000
   */
   ```

   刚才我们看到了then接受两个参数，一个是成功的回调、一个是失败的回调，看起来好像也不是那么优雅，promise里除了then还提供了catch方法：

2. ##### catch捕捉操作

   catch就是专门捕捉错误的回调函数。

   ```js
   let promise = new Promise((resolve, reject) => {
       setTimeout(() => {
           reject(2000)//失败以后这个reject会把失败的结果捕捉到
       }, 1000)
       console.log(11111);
   })
   
   promise.catch(res => {
       console.log(res);//catch里面就能拿到捕捉到的失败结果
   })
   /*
   打印结果：
   11111
   2000 (一秒以后)
   */
   ```

3. ##### finally

   该方法用于指定不管Promise对象最后状态如何，都会执行的操作。

   ```js
   // 服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。
   server.listen(port)
     .then(function () {
       // ...
     }).finally(server.stop);
   ```

   finally 方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是`fulfilled`还是`rejected`。这表明，`finally`方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。

   ```js
   promise
   .finally(() => {
     // 语句
   });
   
   // 等同于
   promise
   .then(
     result => {
       // 语句
       return result;
     },
     error => {
       // 语句
       throw error;
     }
   );
   // finally本质是then的特例，上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。
   ```

4. ##### all

   `Promise.all()`方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。

   现在我们有这么一个需求，一共有三个接口A、B、C，必须三个接口都成功以后，才能发起第四个请求，怎么实现呢？

   ```js
   //链式调用
   let getInfoA = new Promise((resolve, reject) => {
         console.log('小A开始执行了');
         resolve()
       }).then(res => {
         let getInfoB = new Promise((resolve, reject) => {
           console.log('小B开始执行了');
           resolve()
         }).then(res => {
           let getInfoC = new Promise((resolve, reject) => {
             console.log('小C开始执行了');
             resolve()
           }).then(res => {
             console.log("全部执行完了");
           })
         })
       })
   ```

   链式调用一层一层，很不优雅，

   ```js
   // all
   let getInfoA = new Promise((resolve, reject) => {
       console.log('小A开始执行了')
       resolve()
   })
   let getInfoB = new Promise((resolve, reject) => {
       console.log('小B开始执行了')
       resolve()
   })
   let getInfoC = new Promise((resolve, reject) => {
       console.log('小C开始执行了')
       resolve()
   })
   Promise.all([getInfoA, getInfoB, getInfoC]).then(res=>{
       console.log('全部执行完了！');
   })
   ```

   接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。非常完美，非常优雅。

5. ##### race

   `Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。

   ```js
   const p = Promise.race([p1, p2, p3]);
   ```

   上面代码中，只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给`p`的回调函数。

   现在又有一个需求，同样是接口A、B、C，只要有一个响应了，我就可以调接口D，那么怎么实现呢？

   ```js
   //传统方法实现
   
   1、传统方式
   
   let getInfoA = new Promise((resolve, reject) => {
       console.log('小A开始执行了')
       setTimeout((err => {
           resolve('小A最快')
       }),1000)
   }).then(res =>{
       console.log(res)
   })
   let getInfoB = new Promise((resolve, reject) => {
       console.log('小B开始执行了')
       setTimeout((err => {
           resolve('小B最快')
       }),1001)
   }).then(res =>{
       console.log(res)
   })
   let getInfoC = new Promise((resolve, reject) => {
       console.log('小C开始执行了')
       setTimeout((err => {
           resolve('小C最快')
       }),1002)
   }).then(res =>{
       console.log(res)
   })
   /*
   打印结果
   
   小A开始执行了
   小B开始执行了
   小C开始执行了
   小A最快
   */
   ```

   这个方法得写三遍，好像也不是那么优雅，一起来看下race应该怎么写？

   ```js
   
   2、race
   
   let getInfoA = new Promise((resolve, reject) => {
       console.log('小A开始执行了')
       setTimeout((err => {
           resolve('小A最快')
       }),1000)
   })
   let getInfoB = new Promise((resolve, reject) => {
       console.log('小B开始执行了')
       setTimeout((err => {
           resolve('小B最快')
       }),1001)
   })
   let getInfoC = new Promise((resolve, reject) => {
       console.log('小C开始执行了')
       setTimeout((err => {
           resolve('小C最快')
       }),1002)
   })
   Promise.race([getInfoA, getInfoB, getInfoC]).then(res => {
       console.log(res)
   })
   /*
   打印结果
   
   小A开始执行了
   小B开始执行了
   小C开始执行了
   小A最快
   */
   ```

   与Promise.all 相似的是，Promise.race都是以一个Promise对象组成的数组作为参数，不同的是，只要当数组中的其中一个Promsie状态变成resolved或者rejected时，就可以调用.then方法了。

#### Generator函数

​	阮一峰老师文档上的解释：Generator函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。

​	这个函数自己执行不了，得让别人帮忙执行，踢一脚（next()），走一步。

**基本用法**

```js
function* doSomething() {
    yield '吃饭'
    return '睡觉'
}
let newDoSomething = doSomething()//自己执行不了，需要指向一个状态机

console.log(newDoSomething.next()) // {value: "吃饭", done: false}
console.log(newDoSomething.next()) // {value: "睡觉", done: true}
```

**从上面的例子可以看出来，Generator 函数有四个特点：**

1、function后面有个小*，这个地方有两种写法，没啥太大区别；

```text
function* doSomething(){}
function *doSomething(){}
```

2、函数里面会有一个yield，把函数截成不同的状态；

```text
一个yield可以截成两个状态，也就需要两个next()触发；
```

3、Generator函数自己不会执行，而是会返回一个遍历器对象；

4、遍历器对象会通过.next()方法依次调用各个状态。

#### async await

​	什么是 async await

​	async、await是Generator函数的语法糖，原理是通过Generator函数加自动执行器来实现的，这就使得async、await跟普通函数一样了，不用再一直next执行了。

​	他吸收了Generator函数的优点，可以通过await来把函数分状态执行，但是又不用一直next，可以自动执行。

```js
function f() {
    return new Promise(resolve => {
        resolve('hhh')
    })
}
async function doSomething1() {
    let x = await f()
    console.log(x);//hhh
}
doSomething1()
```

看了上面的例子，可以看出async有三个特点：

1. 函数前面会加一个async修饰符，来证明这个函数是一个异步函数；
2. await 是个运算符，用于组成表达式，它会阻塞后面的代码
3. await 如果等到的是 Promise对象，则得到其 resolve的值。

##### async、await项目中的使用

现在有一个封装好的，获取数据的方法，我们分别用promise、Generator、async来实现发请求，做一下比较：

```js
function getList() {
    return new Promise((resolve, reject) =>{
        $axios('/pt/getList').then(res => {
            resolve(res)
        }, err => {
            reject(err)
        })
    })
}
```

##### Promise

```js
function initTable() {
    getList().then(res => {
        console.log(res)
    }).catch(err => {
        this.$message(err) // element的语法
    })
}
/*
然后直接调用就可以
这么做看起来非常的简洁，但是如果多个请求调用
就会是.then,.then看起来非常不舒服
*/
```

##### Generator函数

```js
function *initTable(args) {
    const getList = yield getlist(args)
    return getList
}

function getList() {
    const g = initTable(this.searchParams)
    const gg = g.next().value
    gg.then(res =>{
        this.total = res.data.count
        if (res.data.list) {
          this.tableList = res.data.list
          this.tableList.forEach(e => {
            e.receiveAmt = format(e.receiveAmt)
          })
        } else {
          this.tableList = []
        }
    })
}

//这个看起来就比较伤，写起来非常麻烦
```

##### async await

```js
async initTable() {
    const getData = await getList(this.searchParams)
    return getData
},
getList(){
    this.initTable().then(res=>{
        this.tableList = res.data.list
    })
}
/*
这样写好像也很简单，而且非常方便
主要是如果调用多个接口，可以直接多个await
*/
```

### 9) 浏览器渲染页面的过程

首先输入一个网址，浏览器会向服务器发起DNS请求，得到对应的IP地址（会被缓存一段时间，后续访问就不用再去向服务器查询）。之后会进行tcp三次握手与服务器建立连接，连接建立后，浏览器会代表用户发送一个初始的get请求，通常是请求一个html文件。服务器收到对应请求后，会根据相关的响应头和html内容进行回复。

一旦浏览器拿到了数据，就会开始解析信息，这个过程中，浏览器会根据html文件去构建DOM树，当遇到一些阻塞资源时（如同步加载的script标签）会去加载阻塞资源而停止当前DOM树构建（所以能够异步的或延迟加载的就尽量异步或延迟，同时页面的脚步还是越少越好）。在构建DOM树时，浏览器的主线程被占据着，不过浏览器的预加载扫描器会去请求高优先级的资源（如css、js、字体），预加载扫描器很好的优化了阻塞问题。接下来浏览器会处理css生成的css DOM树，将css规则转换为可以理解和使用的样式映射，这个过程非常快（通常小于一次DNS查询所需时间）。有了DOM树和CSS DOM树，浏览器会将其组合生成一个Render树，计算样式或渲染树会从DOM的根节点开始构建，遍历每一个可见节点（将相关样式匹配到每一个可见节点，并根据CSS级联去的每个节点的计算样式）。接下来开始布局，该过程（依旧是从根节点开始）会确定所有节点的宽高和位置，最后通过渲染器将其在页面上绘制。绘制完成了，并不代表交互也生效了，因为主线程可能还无法抽出时间去处理滚动、触摸等交互，要等到js加载完成，同时主线程空闲了整个页面才是正常可用的状态。

### 10) 性能优化

#### 什么情况下会重绘和回流，常见的改善方案

浏览器请求到对应页面资源的时候，会将html解析成DOM，把css解析成css dom，然后将dom和css DOM合并就产生了Render Tree。在有了渲染树之后，浏览器会根据流式布局模型来计算它们在页面上的大小和位置，最后将节点绘制在页面上。

那么当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变，浏览器就会重新渲染页面，这个就是**浏览器的回流**。常见的回流操作有：页面的首次渲染、浏览器窗口尺寸改变、部分元素尺寸或位置变化、添加或删除可见的DOM、激活伪类、查询某些属性或调用方法（各种宽高的获取，滚动方法的执行等）

当页面中的元素样式改变不影响它在文档流的位置时（如color、background-color等），浏览器对应元素的样式，这个就是**重绘**。

可见：**回流必将导致重绘，重绘不一定会引起回流。回流比重绘的代价更高。**

#### 常见的改善方案：防抖、节流

- 在进行频繁操作时，使用防抖和节流来控制调用频率。（防抖和节流都是用来控制某个函数在一定时间内的触发次数.）

- 避免频繁操作DOM，可以利用DocumentFragment，来进行对应的DOM操作，将最后的结果添加到文档中。

- 灵活使用display：none属性，操作结束后将其显示出来，因为在display的属性为none的元素上进行的DOM操作不会引发回流和重绘

- 获取各种会引起重绘/回流的属性，尽量将其缓存起来，不要频繁的去获取。

- 对复杂动画采用决定定位，使其脱离文档流，否则它会频繁的引起父元素及其后续元素的回流。

#### 一次请求大量数据怎么优化，数据多导致渲染慢怎么优化

大量数据，应该采用异步的方式来接收，对数据进行一个分片处理，可以拆分成一个个的小单元数据，通过自定义的属性进行关联。这样数据分片完成。接下来渲染，由于大量数据，如果是长列表的话，这里就可以使用虚拟列表（当前页面需要渲染的数据拿到进行渲染，然后对前面一段范围以及后面一段范围，监听对应的滚动数据来切换需要渲染的数据，这样始终要渲染的就是三部分）。当然还有别的渲染情况，比如echarts图标大量点位数据优化等。

1. 分页加载：将数据分成多个较小的块进行加载，而不是一次性加载所有数据。通过分页加载，可以减少单次请求的数据量，从而减轻服务器和客户端的负担，提高渲染速度。
2. 延迟加载：只在需要时加载数据，而不是在初始加载时一次性加载所有数据。例如，在滚动到页面底部时才加载下一页的数据，或者在用户点击"加载更多"按钮时才进行数据加载。这样可以避免一次性加载大量数据，提高页面的响应速度。
3. 数据压缩和缓存：对传输的数据进行压缩，以减小数据的大小，从而减少网络传输时间。另外，使用适当的缓存机制，如浏览器缓存或缓存服务器，可以减少对服务器的请求次数，提高数据获取的速度。
4. 后端优化：在服务器端进行性能优化，如使用合适的数据库索引、优化查询语句、增加服务器资源等，以加快数据的检索和传输速度。
5. 前端优化：在前端代码中使用合适的技术和工具来优化数据的渲染速度。例如，使用虚拟滚动（Virtual Scrolling）或无限滚动（Infinite Scrolling）来优化大量数据的展示，只渲染可见区域的数据，而不是全部数据。
6. 数据预处理：如果可能的话，在服务器端对数据进行处理和过滤，以减少传输到前端的数据量。只传输前端需要的数据，可以减少不必要的网络传输和前端渲染的工作量。
7. 异步加载：使用异步加载技术，如AJAX或Fetch API，在后台获取数据的同时，不阻塞页面的加载和渲染。这样可以提高用户体验，让用户能够更快地与页面进行交互。

### 11) 防抖和节流

|              | 防抖（debounce）                                             | 节流（throttle）                                             |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 含义         | 单位时间内，频繁触发事件，只执行最后一次                     | 单位时间内，频繁触发事件，只执行一次                                                                      ------------------------------------------------------------- |
| 举例         | 设定1000毫秒定时器，当触发事件了，它会在1000毫秒之后执行，但是在还剩500毫秒的时候又触发了事件，那就会重新开始1000毫秒后执行。 | 设定1000毫秒执行，如果在1000毫秒内触发多次，也只在1000毫秒后执行一次。 |
| 代码实现思路 | 利用定时器，每次触发先清掉以前的定时器(**从新开始**)         | 利用定时器，等定时器执行完毕，才开启定时器(**不要打断**)     |
| 应用场景     | 英雄回城；搜索框搜索输入；登录、短信验证等按钮避免用户点击太快，发行多次请求；文本编辑器实时保存等。 | 英雄技能冷却；快速点击；鼠标滑动；监听滚动事件；下拉加载。等 |

```js
//防抖 - 单位时间内，频繁触发事件，只执行最后一次，英雄联盟回城
//<button>点击</button>
<script>
    var timer = null;
    function debounce() {
        // 首次执行timer是null,后续执行都需要先清除一下定时器，从新开始
        if (timer !== null) {
            clearTimeout(timer)
        }
        // 执行一次之后timer会变成1，后续++
        timer = setTimeout(() => {
            console.log('防抖');
        }, 1000)
    }
</script>
```

```js
// 节流 - 单位时间内，频繁触发事件，只执行一次，英雄联盟技能冷却
//<button>点击</button>
<script>
    var timer = null;
    function throttle() {
        if (timer !== null) {//如果timer还未置空，说明时间没到 return掉
            return
        }
        timer = setTimeout(() => {//打印节流，并2s后timer置空
            console.log('节流');
            timer = null;
        }, 2000);
    }
    var btn = document.querySelector('button');
    btn.addEventListener('click', () => {
        throttle()
    })
</script>
```

### 12) 浅拷贝和深拷贝

#### 浅拷贝

​	含义：把数组/对象中**第一层**的值，复制到新的数组/对象中的过程

​	使用场景：修改数组/对象，会影响另一个数组/对象时，想砍断它们的联系时使用

​	如何实现：for / for...in / 扩展运算符

```js
let a = 100;
let b = a;
a = 50;
console.log(b);//100
/*
   分析过程：定义了一个变量a，并赋值为100，
            声明一个变量b，把a里面的值赋予了a，则a=100;
            给a再次赋值50，此时a变为50；
            b未发生改变还是100
*/ 

let arr = ["小黑","小白"];
let brr = arr;
arr.push("小王");
console.log(brr);//['小黑', '小白', '小王']
/*
   分析过程：
        定义了一个变量arr，并赋值数组为 ["小黑","小白"]，当新定义一个数组/对象时，它首先会到堆内存中申请一块内存空间，每一块内存空间都有一个内存地址(0x00)，在内存空间里面会保存数组,所以arr里面装的就是内存地址，此内存地址指向堆内存中内存空间的真正数据

        声明一个变量brr，把arr里面的值赋予了arr，则brr里面装了和arr一样的内存地址(0x00);也指向堆内存中内存空间的真正数据

        当给arr指向的堆内存中添加一个新数据"小王"时，因为arr和brr指向同一个地址，所以brr也会变成['小黑', '小白', '小王']
*/ 

// let obj = {

//     name:'小李',
//     age:18
// }
// let obj2 = obj;
// obj.name = '小刘';
// console.log(obj2.name);//小刘
// 分析过程与数组分析过程一致，都是指向同一个内存地址

//1.for in 浅拷贝
let obj = {
    name:'小李',
    age:18
}
let obj2 = {};
for (const key in obj) {
    obj2[key] = obj[key]
}
obj.name = '小刘';
console.log(obj2.name);//小李
/*
只要新建一个数组对象就在堆内存中申请一块新的地址
  分析过程：
     声明了一个变量obj，则在堆内存中申请一个空间保存obj对象，并把内存地址(0x00)赋值给了obj，obj指向 0x00

     声明了一个obj2，则在堆内存中申请另一个空间保存obj2的空对象，并把内存地址(0x01)赋值给了obj2，obj2指向0x01

     使用for in 将obj里面的属性和值都复制给obj2里面

     修改了obj里面的name为'小刘'，因为obj和obj2指向不同，则obj2里面的name不会受影响
*/ 

//2.扩展运算符... 浅拷贝
let obj3 = {
    name:'小米',
    age:24
}

let obj4 = {...obj3}
console.log(obj4);//{name: '小米', age: 24}

// 3.Object.assign合并
let obj5 = {
    name:'小菜',
    age:27
}

let obj6 = Object.assign({},obj5);
console.log(obj6);//{name: '小菜', age: 27}
```

**浅拷贝的问题**：只能拷贝第一层的值，第二层的值还是相互引用

​	注意：只要看到一个新的对象或数组，都会在堆内存中开辟一个新的空间

```js
let arr = ["小刘","小明",["小花"]];
let brr = [...arr];
console.log(brr);//["小刘","小明",["小花"]]
arr[2].push("小黑")
console.log(brr);//["小刘","小明",["小花","小黑"]]

/*
 分析过程：
    arr里面是一个二维数组，每遇到一个[]都要开辟一个新的内存地址
    
    let arr = ["小刘","小明",["小花"]];相当于在堆内存中开辟了一个内存地址，0x001,存放着["小刘","小明",0x002],0x002存放着["小花"]，arr里面一层数组里面只放着小花的内存地址，真正的值在新的内存地址0x002放着

    所以拷贝出来的brr里面小花也是放着0x002的内存地址，arr和brr里面的都指向同一个内存地址，所以当arr[2].push("小黑")时，brr里面的值也会发生变化
*/ 
```

#### 深拷贝

​	含义：把数组/对象中**所有层**的值，复制到新的数组/对象中的过程

​	如何实现：创建新数组/对象，判断是基础数据类型则直接赋值，是对象类型(包括数组)则递归调用函数，继续创建判断

```js
let obj = {
    name: '小明',
    age: 18,
    grade: [100, 80],
    family: {
        fName: "王"
    }
}
// 深拷贝obj里面的所有值
let newObj = {}

function deepClone(newObj, obj) {
    for (const key in obj) {//key是：name、age、grade、family
        let value = obj[key];//obj[key] 就是obj的每一项的value 即：小明、18、[100,80]、{fName:"王"}
        if (value instanceof Array) {//如果拿到的值是数组
            newObj[key] = [];//{name:"小明",age：18,grade:[]}
            deepClone(newObj[key], value)
        } else if (value instanceof Object) {//如果拿到的值是对象
            newObj[key] = {};//{name:"小明",age：18,grade:[],family:{}}
            deepClone(newObj[key], value)
        }else{//拿到的数据就是基本数据类型，直接复制就可
            newObj[key] = value;
        }
    }
}

/*
分析过程：
  deepClone()方法用于克隆obj里面的所有数据给newObj这个空对象，
  首先循环obj，key即是obj的属性名，obj[key]即为obj的属性值,
  拿到obj中的每一项的值用value接住,
  然后判断value是否为数组/对象，引用数据类型还需要递归拷贝一次，当value拿到obj中的数组时，newObj[key] = [];意思为新数组newObj里面也添加一个名为grade的空数组即{name:"小明",age：18,grade:[]}，然后拿newObj[key] = []空数组 和 obj里面的数据[100, 80]继续递归，将[100, 80]复制到newObj的grade中即完成了对数组的拷贝
  对象拷贝和数组同理，只不过换成对象而已
*/ 
```

####  手写深拷贝

```js
function deepCopy(obj) {
    if (typeof obj !== 'object' || obj === null) {
        // 如果传人的参数不是对象或 是null，则直接返回该参数
        return obj;
    }
    
    // 根据obj的类型创建一个新的空对象或数组，必须先数组后对象，因为对象是数组的父集
    // Array.isArray() 判断是否为数组
    const newObj = Array.isArray(obj) ? [] : {};
    
    // 遍历obj的属性
    for (let key in obj) {
        // 递归调用deepCopy函数，对每个属性进行深拷贝
        newObj[key] = deepCopy(obj[key]);
    }
    
    return newObj;
}
```

使用该函数进行深拷贝时，它会递归遍历对象的所有属性，并创建一个完全独立的副本。这样可以确保修改副本的属性不会影响原始对象。

示例：

```js
const obj = {
    name : 'JJLin',
    age:42,
    address :{
        city: 'LA',
        country:'USA'
    }
}

const copy = deepCopy(obj);
console.log(copy);
// 输出: { name: 'John', age: 30, address: { city: 'LA', country: 'USA' } }

//修改副本的属性
copy.name = 'JAYChou';
copy.address.city = 'New York';

console.log(copy);
// 输出: { name: 'JAYChou', age: 42, address: { city: 'New York', country: 'USA' } }

console.log(obj);
// 输出: { name: 'JJLin', age: 42, address: { city: 'LA', country: 'USA' } }
```

### 13）手写快速排序

```js
function quickSort(arr) {
    if(arr.length <= 1){
        return arr
    }
    
    const pivotIndex = Math.floor(arr.length / 2);
    const pivot = arr[pivotIndex];
    const left = [];
    const right = [];
    
    for (let i = 0; i < arr.length; i++) {
        if (i === pivotIndex) {
            continue;
        }
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return [...quickSort(left), pivot, ...quickSort(right)];
}
//这是递归实现快速排序算法。它选择数组中间的元素作为基准值（pivot），然后将数组分为两部分：小于基准值的元素放在左边，大于基准值的元素放在右边。然后，对左右两个部分分别进行递归排序，最后将结果合并起来。
```

示例

```js
const arr = [5,2,9,1,7,6,3];
const sortedArr = quickSort(arr);
console.log(sortedArr);  // 输出: [1, 2, 3, 5, 6, 7, 9]
```

这只是一个简单的快速排序算法示例，可能并不适用于所有情况。在实际应用中，可能需要考虑性能优化、处理重复元素等问题。同时，还要注意快速排序的时间复杂度为O(n log n)，在处理大规模数据时可能需要考虑性能问题。

### 14）输入为两个一维数组，将这两个数组合并，去重，不要求排序，返回一维数组

```js
function mergeAndDeduplicateArrays(arr1,arr2) {
    const mergedArray = arr1.concat(arr2);
    const deduplicatedArray = [...new Set(mergedArray)];
    return deduplicatedArray;
}
```

这个函数将两个数组`arr1`和`arr2`合并成一个新的数组`mergedArray`，然后使用ES6的Set数据结构对新数组进行去重操作，得到去重后的数组`deduplicatedArray`。最后，将去重后的数组作为结果返回。

你可以调用这个函数来合并和去重两个数组，例如：

```js
const arr1 = [1, 2, 3];
const arr2 = [2, 3, 4, 5];
const mergedAndDeduplicatedArray = mergeAndDeduplicateArrays(arr1, arr2);
console.log(mergedAndDeduplicatedArray);  // 输出: [1, 2, 3, 4, 5]
```

### 15）JS中call、apply、bind的区别

​	在JavaScript中，call()、apply()、bind()是用于改变函数执行上下文(即this指向)的方法。

**call()** 方法允许以指定的this值和单独给出的参数列表来调用函数，语法 `funcion.call(thisArg,arg1,arg2,...)` ，第一个参数表示this要指向的对象，其余参数表示调用函数需要传入的参数，返回调用函数的返回结果，属于立即执行函数；

你可以用一个对象来替换当前对象，然后在新对象的环境中调用函数

```js
function sayHello() {
    console.log('Hello ' + this.name);
}

let person = {name:'JJLin'};
sayHello.call(person) //HelloJJLin
```

call()应用

```js
function Person(name) {
    this.name = name;
    this.say = function () {
        console.log("我是" + this.name);
    }
}

function Student(studentNo,name) {
    this.studentNo = studentNo;
    // 此this指向Student
    // 通过改变this指向，使Person里的this指向Student
    // 从而实现使用Student就拥有Person里的name属性以及say方法，即实现继承
    // 具体来说，下述代码会执行Person函数，并将当前Student函数中的this指向传递给Person函数，同时还会传入name参数。这样一来Person函数中使用this.name = name的赋值操作，实际上会将name属性添加到Student实例对象上，从而实现了对Person中属性的继承。
    // 这种继承方式称为借用构造函数，它允许一个构造函数在另一个构造函数内部被调用，并将当前对象作为新构造函数的 this。
    Person.call(this,name)
}

// 实例化Student
let student1 = new Student("20240104","小白");
student1.say();//我是小白
console.log("姓名："+student1.name+",学号："+student1.studentNo);//姓名：小白,学号：20240104
```

**apply()** 方法与call()类似，区别在于它接收两个参数，第二个参数是一个参数数组而不是一些列参数，语法 `function.apply(thisArg, [argsArr])`，第一个参数表示this要指向的对象，第二个参数表示调用函数需要传入的参数所组成的数组，返回调用函数的返回结果，属于立即执行函数；

```js
function intr(greeting,farewell) {
    console.log(greeting + ',' + this.name);//Hello,JJLin
    console.log(farewell + ',' + this.name);//Goodbye,JJLin
}
let person = {name:'JJLin'}

intr.apply(person,['Hello', 'Goodbye'])
```

```js
// 此处若用let声明，则第一个调用函数输出undefined
// 此处let声明的变量虽然也是全局变量但其不会成为全局对象window的属性，因为ES6 标准中，let 声明的变量不会被添加到全局对象上，从而避免了全局变量的污染和不可预测的行为。故say()直接调用时为undefined

var word = '我是window';
function say(params1,params2) {
    console.log(params1+" " + params2 +"," + this.word);
}

let obj = {
    word: "我是obj"
}
let newObj = {
    word:"我是newObj"
}

say("Hi","friend")//Hi friend,我是window  //let 声明 则输出：Hi friend,undefined
say.call(obj,"Hi","friend")//Hi friend,我是obj    this指向obj
say.apply(newObj,["Hi","friend"]) //Hi friend,我是newObj   this指向newObj
```

**bind()** 接收一个及其以上的参数，和call()一致，但bind方法创建一个新的函数，当被调用时，将其this值设为提供的值，然后再调用原函数。bind() 不会立即执行，而是返回一个新的函数,而不是调用新函数的返回结果。

```js
let person = {name:'JJLin'};
function sayHi() {
    console.log('Hi ' + this.name);
}
let sayHiAgain = sayHi.bind(person);
sayHiAgain()//Hi JJLin
```

```js
var obj = {};
function test() {
    console.log(this === obj);
}
test()// false

var testObj = test.bind(obj);
testObj()//true
```

```js
var word = "我是window";
function say(params1, params2) {
    console.log(params1 + " " + params2 + "，" + this.word)
}
let Obj1 = {
    word: "我是newObj1"
}
let Obj2 = {
    word: "我是newObj2"
}
//返回一个新的函数
let newFunc = say.bind(Obj1, "hello", "friend");
newFunc()   //hello friend，我是newObj1

//可将其改为立即执行函数，此时返回和call()，apply（）相同
say.bind(Obj2, "hello", "friend")();   //hello friend，我是newObj2
```

区别：

- 当我们使用一个函数需要改变this指向时才会用到 call、apply、bind
- 如果传递的参数不多，则使用 `fn.call(obj,arg1,arg2,...)`
- 如果传递的参数很多，则可以使用数组整理好参数，调用 `fn.apply(obj,[arg1,arg2,...])`
- 如果想生成一个新对象长期绑定某个函数供某个对象使用，则使用const newFn = fn.bind(this.obj) newFn(arg1,arg2,...)

### 16）Object.key和Object.values用法

**`Object.keys()`** 静态方法返回一个由给定对象自身的可枚举的字符串键 **属性名** 组成的数组。

**`Object.values()`** 静态方法返回一个给定对象的自有可枚举字符串键 **属性值 **组成的数组。

```js
const object = {
  a: 'somestring',
  b: 42,
  c: false,
};
console.log(Object.keys(object));//['a', 'b', 'c']

console.log(Object.values(object));//['somestring', 42, false]
```

### 17）JavaScript中遍历数组和对象的方法

数组：

1. for循环

   最基本的循环遍历函数

   ```js
   const items = ["item1", "item2", "item3"];
   const copyItems = [];
   for (let i = 0; i < items.length; i++) {
       copyItems.push(items[i]);
   }
   console.log(copyItems);//['item1', 'item2', 'item3']
   ```

2. for...of

   适用于遍历可迭代对象，例如数组、字符串、Map、Set等

   利用 for...of 可以 **遍历集合中的值 **而不是索引。

   ```js
   const items = ["item1", "item2", "item3"];       
   for (const e of items) {
       console.log(e); //item1  item2  item3
   }
   ```

3. forEach()

   数组的方法，用于对数组中每个元素执行指定操作。

   适用于需要对数组的每个元素进行操作。

   ```js
   const items = ["item1", "item2", "item3"];
   const copyItems = [];
   items.forEach(e => {
       copyItems.push(e);
   });
   console.log(copyItems);//['item1', 'item2', 'item3']
   ```

4. map()

   类似forEach，不同之处是map会返回一个新数组，该数组的元素是对原数组每个元素调用回调函数后的返回值。

   ```js
   let arr = [1, 2, 3, 4];
   let newArr = arr.map((e) => e * 2);// 对数组中的每个元素乘以2
   console.log(newArr);//[2, 4, 6, 8]
   ```

5. filter()

   用于筛选数组中所有符合指定条件的 **所有元素**，并返回一个由这些元素组成的新数组，没找到返回空数组

   ```js
    let arr = [1, 2, 3, 4];
    let newArr = arr.filter((e) => e > 2)
    console.log(newArr);// [3, 4]
   ```

6. find()

   用于查找数组中符合指定条件的 **第一个元素**，并返回改元素的值，如果没有找到则返回undefined

   ```js
   let arr = [1, 2, 3, 4];
   let newArr = arr.find((e) => e > 2)
   console.log(newArr);// 3
   ```

7. every()

   用于检查数组中**所有元素**是否都符合指定条件，如果是返回true，否则返回false。如果数组为空，则返回true。

   ```js
   const arr = [2, 4, 6, 8, 10];
   const result = arr.every(e => e % 2 === 0);
   console.log(result); // 输出: true
   ```

8. some()

   用于检查数组中是否**至少有一个元素**符合指定条件，如果是则返回 true，否则返回 false。如果数组为空，则返回 false。

   ```js
   const arr = [1, 3, 5, 7, 10];
   const result = arr.some(e => e > 5);
   console.log(result); // 输出: true
   ```

9. reduce()

   用于将数组中的元素进行累积操作，最终返回一个值，它接受一个回调函数作为参数，且可以指定一个初始值。

   ```js
   array.reduce(function(accumulator, currentValue, currentIndex, array) {
     // ... 执行累积操作的逻辑 ...
   }, initialAccumulatorValue);
   /*
   1.function(accumulator, currentValue, currentIndex, array): 这是一个回调函数，用于指定累积操作。
   	参数 accumulator 代表累积的结果，
   	     currentValue 代表当前处理的元素，
   	     currentIndex 表示当前处理元素的索引，
   	     array 表示当前被处理的数组。
   2.initialAccumulatorValue: 可选参数，用于指定初始的累积值。如果指定了初始值，累积操作会从初始值开始；如果没指定，则累积操作会从数组的第一个元素开始。
   */
   const arr = [1, 2, 3, 4, 5, 6];
   const sum = arr.reduce((pre, current) => pre + current, 0);
   console.log(sum);//21
   ```

10. for...in

    for...in 不仅可以遍历对象也可以遍历数组，因为数组也只是一种特殊对象。

    ```js
    var a = [1,2,3]
    for(var i in a){
        console.log(a[i])//1 2 3
    }
    ```

    但是，`for...in`不仅会遍历数组所有的数字键，还会遍历非数字键。所以，**不推荐 **使用`for...in` **遍历数组**。

    ```js
    var a = [1, 2, 3]
    a.foo = true
    for (var i in a) {
        console.log(a[i])//1 2 3 true
    }
    ```

对象：

1. for...in

   用于遍历对象的可枚举属性。

   适用于遍历对象的属性，对于数组，`for...in`也会遍历数组的原型链上的属性，所以通常不建议用于遍历数组。

   ```js
   let obj = {
       a: 1,
       b: 2,
       c: 3
   };
   for (let key in obj) {
       console.log(key, obj[key]); // a 1  b 2  c 3
   }
   ```

2. Object.keys()

   返回一个包含对象的所有可枚举属性的**键**的数组。

   ```js
   const obj = { a: 1, b: 2, c: 3 };
   const keys = Object.keys(obj);
   console.log(keys); // 输出: ['a', 'b', 'c']
   ```

3. Object.values()

    返回一个包含对象的所有**值**的数组。

   ```js
   const obj = { a: 1, b: 2, c: 3 };
   const values = Object.values(obj);
   console.log(values); // 输出: [1, 2, 3]
   ```

4. Object.entries()

   返回一个包含对象的所有可枚举属性的键值对数组。

   ```js
   const obj = { a: 1, b: 2, c: 3 };
   const entries = Object.entries(obj);
   console.log(entries); // 输出: [['a', 1], ['b', 2], ['c', 3]]
   ```

### 18）JavaScript中检查变量类型的方法

1. `typeof` 运算符

   `typeof` 用于检查变量的数据类型，返回一个表示数据类型的字符串。

   ```js
   typeof "hello";  // 返回 "string"
   typeof 42;       // 返回 "number"
   typeof true;     // 返回 "boolean"
   ```

2. `instanceof` 运算符

   `instanceof` 运算符用于判断一个对象是否是一个类的实例。它通过检查对象的原型链来确定对象是否属于特定的类。通常用于判断自定义对象的类型。

   ```js
   function Person(name) {
       this.name =  name
   }
   let p1 = new Person('JJLin')
   console.log(p1 instanceof Person);//true
   ```

3. `Array.isArray`

   `Array.isArray`方法可以确定一个变量是否为数组类型。该方法在确定一个变量是否为数组时非常有用。

   ```js
   Array.isArray([]);    // 返回 true
   Array.isArray({});    // 返回 false
   ```

4. `Object.prototype.toString.call`

   使用 `Object.prototype.toString.call` 方法可以确定一个变量的类型，返回一个字符串，表示对象的类型。

   ```js
   Object.prototype.toString.call("hello"); // 返回 "[object String]"
   Object.prototype.toString.call(42);      // 返回 "[object Number]"
   ```









































