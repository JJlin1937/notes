[TOC]
## 一、HTML

## 二、CSS

### 1.CSS 选择器及其优先级

|     选择器     |     格式      | 优先级权重 |
| :------------: | :-----------: | :--------: |
|   id 选择器    |      #id      |    100     |
|    类选择器    |  .className   |     10     |
|   属性选择器   | a[ref='eee']  |     10     |
|   伪类选择器   | li:last-child |     10     |
|   标签选择器   |      div      |     1      |
|  伪元素选择器  |   li:after    |     1      |
| 相邻兄弟选择器 |    h1 + p     |     0      |
|    子选择器    |     ul>li     |     0      |
|   后代选择器   |     ul li     |     0      |
|  通配符选择器  |       *       |     0      |

**属性选择器** 允许你选择具有指定属性的元素

```css
/* 选择具有 title 属性的所有元素 */
[title] {
    color: red;
}
/* 选择 title 属性值为 "example" 的所有元素 */
[title="example"] {
    font-size:16px;
}
/* 选择 href 属性值以 "https://" 开头的所有链接元素 */
[href^="https://"] {
    background-color:red;
}
/* 选择 src 属性值以 ".png" 结尾的所有图片元素 */
[src$=".png"] {
    border:1px solid black;
}
/* 选择 class 属性值包含 "button" 的所有元素 */
[class*="button"] {
    padding:5px;
}
```

**伪类选择器** 用于匹配处于特定状态的元素，例如鼠标悬停在元素上、元素是链接的一部分、或者是子元素中的第一个、最后一个等等。

1. **:hover**：选择鼠标悬停在元素上的状态。
2. **:active**：选择元素被激活的状态，比如用户点击了它但尚未释放鼠标按钮。
3. **:focus**：选择当前拥有键盘输入焦点的元素。
4. **:nth-child(n)**：选择元素的第 n 个子元素。
5. **:first-child**：选择元素的第一个子元素。
6. **:last-child**：选择元素的最后一个子元素。
7. **:not(selector)**：选择不匹配给定选择器的元素。

**伪元素选择器** 用于向文档树中的元素添加额外的内容或样式，例如在元素的前面或后面插入内容，或者为元素的首行或首字母添加样式。

1. **::before**：在元素内容之前插入生成的内容。
2. **::after**：在元素内容之后插入生成的内容。
3. **::first-line**：选择元素的第一行文本。
4. **::first-letter**：选择元素的第一个字母。

```css

/* 鼠标悬停时改变链接颜色 */
a:hover {
    color: red;
}

/* 为每个段落的第一个字母添加样式 */
p::first-letter {
    font-size: 150%;
}
```

对于选择器的 **优先级：**

- 标签选择器、伪元素选择器：1
- 类选择器、伪类选择器、属性选择器：10
- id 选择器：100
- 内联样式：1000

**注意事项**：

- !important 声明的样式优先级最高
- 如果优先级相同，则最后出现的样式生效
- 继承得到的样式优先级最低
- 通用选择器（*）、子选择器（>）和相邻同胞选择器（+）并不在这四个等级中，所以它们权值为0
- 样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式

### 2. display 的属性值及其作用

| 属性值       | 作用                                                       |
| ------------ | ---------------------------------------------------------- |
| none         | 元素不显示，并且会从文档流中移除。                         |
| block        | 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。       |
| inline       | 行内元素类型，默认宽高为内容宽高，不可设置宽高，同行显示。 |
| inline-block | 默认宽高为内容宽高，可以设置宽高，同行显示。               |
| list-item    | 像块类型元素一样显示，并添加样式列表标记。                 |
| table        | 此元素会作为块级表格来显示。                               |
| inherit      | 规定应该从父元素继承display属性的值。                      |

### 3. display的block、inline和inline-block的区别

- **block：**会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；
- **inline：**元素不会独占一行，设置width、height属性无效。但可以设置padding(水平+垂直均可)和水平方向的margin属性，不能设置垂直方向的margin；
- **inline-block：**将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。

对于行内元素和块级元素，其特点如下：

**（1）行内元素** 

​	span、a、strong、img、br、input等 

​	行内元素默认在一行内显示，宽度和高度由其内容决定，不能设置宽度和高度。

- 设置宽高无效；
- 可以设置padding(水平+垂直均可)和水平方向的margin属性，不能设置垂直方向的margin；
- 不会自动换行；

**（2）块级元素**

​	div、p、h1~h6、ul、li等

​	块级元素则会在页面上独自占据一行，可以设置宽度、高度以及其他盒模型属性。

- 可以设置宽高；
- 设置margin和padding都有效；
- 可以自动换行；
- 多个块状，默认排列从上到下。

### 4.隐藏元素的方法有哪些

- **display: none**：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。
- **visibility: hidden**：元素在页面中仍占据空间，但是不会响应绑定的监听事件。
- **opacity: 0**：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。
- **position: absolute**：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。
- **z-index: 负值**：来使其他元素遮盖住该元素，以此来实现隐藏。
- **clip/clip-path** ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。
- **transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。

### 5.解决浮动元素引起的父元素高度塌陷的问题

​	当父元素包含浮动元素时，它的高度可能会塌陷，导致布局混乱。通过在父元素上应用一个 clearfix 类，然后使用伪元素 `::after` 来清除浮动，可以确保父元素的高度被正确计算，从而解决这个问题。

```html
<style>
div {
  border: 3px solid #4CAF50;
  padding: 5px;
}
.clearfix::after {
  content: "";
  clear: both;
  display: table;
}

.img2 {
  float: right;
}
</style>
<div class="clearfix">
  <h1>With Clearfix</h1>
  <img class="img2" src="/i/logo/w3logo-3.png" alt="W3School" width="180" height="167">
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus imperdiet, nulla et dictum interdum...
</div>
```

### 6.css中的 var() 函数用法

var() 函数用于插入 CSS 变量的值。

var() 函数的语法如下：

```
var(name, value)
```

| 值      | 描述                                 |
| :------ | :----------------------------------- |
| *name*  | 必需。变量名（以两条破折号开头）。   |
| *value* | 可选。回退值（在未找到变量时使用）。 |

**注释：**变量名称必须以两个破折号（--）开头，且区分大小写！

```html
<style>
:root {
  --blue: #1e90ff;
  --white: #ffffff; 
}
h2 {
  border-bottom: 2px solid var(--blue);
}
button {
  --button-blue: red;
  background-color: var(--white);
  color: var(--button-blue);
  border: 1px solid var(--button-blue);
  padding: 5px;
}
</style>
</head>
<body>

<h1>使用 var() 函数</h1>

<div class="container">
  <h2>Welcome to Shanghai!</h2>
  <p>
    <button>Yes</button>
    <button>No</button>
  </p>
</div>
</body>
```

有时，我们希望变量仅在页面的特定部分中进行更改。

假设我们想要按钮元素使用不同的颜色色。那么，我们可以在 button 选择器内重新声明 --blue 变量。当我们在这个选择器中使用 var(--blue) 时，它将使用此处声明的局部 --blue 变量值。

我们看到局部的 --blue 变量会覆盖 button 元素的全局 --blue 变量：

```css
button {
  --button-blue: #0000ff;
  background-color: var(--white);
  color: var(--button-blue);
  border: 1px solid var(--button-blue);
  padding: 5px;
}
```

### 7.对盒模型的理解

CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型

盒模型都是由四个部分组成的，分别是margin、border、padding和content。

标准盒模型和IE盒模型的区别在于设置`width`和`height`时，所对应的范围不同：

- 标准盒模型的`width`和`height`属性的范围只包含了`content`，
- IE盒模型的`width`和`height`属性的范围包含了border、padding和content。

可以通过修改元素的box-sizing属性来改变元素的盒模型：

- `box-sizing: content-box`表示标准盒模型（默认值）
- `box-sizing: border-box`表示IE盒模型（怪异盒模型）

### 8.flex 弹性布局

在 Flexbox 布局模块（问世）之前，可用的布局模式有以下四种：

- 块（Block），用于网页中的部分（节）
- 行内（Inline），用于文本
- 表，用于二维表数据
- 定位，用于元素的明确位置

注意，设为Flex布局以后，**子元素的float、clear和vertical-align属性将失效**。采用Flex布局的元素，称为Flex容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称"项目"。

| 属性                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [display](https://www.w3school.com.cn/cssref/pr_class_display.asp) | 规定用于 HTML 元素的盒类型。浮动使用flex（display: flex）    |
| [flex-direction](https://www.w3school.com.cn/cssref/pr_flex-direction.asp) | 规定弹性容器内的弹性项目的方向。<br />水平：row 从左到右；row-reverse 从右到左<br />垂直：column 自上而下；column--reverse 自下而上 |
| [justify-content](https://www.w3school.com.cn/cssref/pr_justify-content.asp) | 当弹性项目没有用到主轴上的所有可用空间时，水平对齐这些项目。<br />justify-content: center; 中心对齐<br />justify-content: flex-start;flex 项目在容器的开头对齐（默认）<br />justify-content: flex-end;flex 项目在容器的末端对齐<br />justify-content: space-around;显示行之前、之间和之后带有空格的 flex 项目<br />justify-content: space-between;显示行之间有空格的 flex 项目 |
| [align-items](https://www.w3school.com.cn/cssref/pr_align-items.asp) | 当弹性项目没有用到主轴上的所有可用空间时，垂直对齐这些项。<br />align-items: center;flex 项目在容器中间对齐<br />align-items: flex-start;将 flex 项目在容器顶部对齐<br />align-items: flex-end;将弹性项目在容器底部对齐<br />align-items: stretch;拉伸 flex 项目以填充容器（默认）<br />align-items: baseline;使 flex 项目基线对齐 |
| [flex-wrap](https://www.w3school.com.cn/cssref/pr_flex-wrap.asp) | 规定弹性项目是否应该换行，若一条 flex 线上没有足够的空间容纳它们。<br />换行：flex-wrap: wrap;  <br />不换行：flex-wrap: nowrap;(默认)<br />相反顺序换行：flex-wrap: wrap-reverse; |
| [align-content](https://www.w3school.com.cn/cssref/pr_align-content.asp) | 修改 flex-wrap 属性的行为。与 align-items 相似，但它不对齐弹性项目，而是对齐 flex 线。<br /> |
| [flex-flow](https://www.w3school.com.cn/cssref/pr_flex-flow.asp) | flex-direction 和 flex-wrap 的简写属性。<br />flex-flow: row wrap; 横向排布，换行 |
| [order](https://www.w3school.com.cn/cssref/pr_order.asp)     | 规定弹性项目相对于同一容器内其余弹性项目的顺序。             |
| [align-self](https://www.w3school.com.cn/cssref/pr_align-self.asp) | 用于弹性项目。覆盖容器的 align-items 属性。                  |
| [flex](https://www.w3school.com.cn/cssref/pr_flex.asp)       | flex-grow、flex-shrink 以及 flex-basis 属性的简写属性。      |

##### flex:1 表示什么

flex属性是flex-grow，flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。**flex:1 表示 flex: 1 1 0%**：

它通常用于设置 flex 容器中的 flex 项目（flex items）的伸缩性，以便它们能够根据可用空间自动调整大小。

- 第一个参数表示: **flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大；**
- 第二个参数表示: **flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小；**
- 第三个参数表示: **flex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小。**

具体来说，`flex: 1;` 将会给一个 flex 项目分配一个相对于其他 flex 项目相同的比例空间。这意味着它将占据尽可能多的可用空间，而不是固定的大小。

例如，如果有两个子项目，其中一个具有 `flex: 1;`，另一个没有设置 `flex` 属性，则具有 `flex: 1;` 的项目将占据可用空间的大部分，而另一个项目将占据剩余的空间。如果有更多的子项目，它们将根据相同的比例分配可用空间。

```css
/* 弹性盒的容器 */
.row {
  display: flex;
  flex-wrap: wrap;
}

/* 创建四个相等的列 */
.column {
  flex: 25%;
  padding: 20px;
}

/* 在 992px 或更小的屏幕上，从四列变为两列 */
@media screen and (max-width: 992px) {
  .column {
    flex: 50%;
  }
}

/* 在宽度小于或等于 600 像素的屏幕上，使各列堆叠，而不是并排 */
@media screen and (max-width: 600px) {
  .row {
    flex-direction: column;
  }
}
```

在 `flex: 25%;` 中，`25%` 是 `flex-basis` 的值，意味着这个元素的初始大小将是其容器宽度的25%。这个声明告诉浏览器，每个子元素都应该占据父容器宽度的四分之一。

### 9.媒体查询

媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。

```css
/* 超小型设备（电话，600px 及以下） */
@media only screen and (max-width: 600px) {...} 

/* 小型设备（纵向平板电脑和大型手机，600 像素及以上） */
@media only screen and (min-width: 600px) {...} 

/* 中型设备（横向平板电脑，768 像素及以上） */
@media only screen and (min-width: 768px) {...} 

/* 大型设备（笔记本电脑/台式机，992px 及以上） */
@media only screen and (min-width: 992px) {...} 

/* 超大型设备（大型笔记本电脑和台式机，1200px 及以上） */
@media only screen and (min-width: 1200px) {...}
```

### 10.display:none与visibility:hidden的区别

这两个属性都是让元素隐藏，不可见。**两者区别如下：**

（1）**在渲染树时**

- `display:none` 会让元素完全从渲染树中消失，渲染时不会占据任何空间
- `visibility:hidden` 不会让元素从渲染树中消失，渲染的元素还会占据相应空间，只是内容不可见

（2）**是否为继承属性**

- `display:none`是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；
- `visibility:hidden`是继承属性，子孙节点消失是由于继承了`hidden`，通过设置`visibility:visible`可以让子孙节点显示；

（3）修改常规文档流中元素的 `display` 通常会造成文档的重排，但是修改`visibility`属性只会造成本元素的重绘；

（4）如果使用读屏器，设置为`display:none`的内容不会被读取，设置为`visibility:hidden`的内容会被读取。

### 11.伪元素和伪类的区别和作用？

- 伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：

#####  CSS 伪元素

| 选择器                                                       | 例子            | 例子描述                      |
| :----------------------------------------------------------- | :-------------- | :---------------------------- |
| [::after](https://www.w3school.com.cn/cssref/selector_after.asp) | p::after        | 在每个 <p> 元素之后插入内容。 |
| [::before](https://www.w3school.com.cn/cssref/selector_before.asp) | p::before       | 在每个 <p> 元素之前插入内容。 |
| [::first-letter](https://www.w3school.com.cn/cssref/selector_first-letter.asp) | p::first-letter | 选择每个 <p> 元素的首字母。   |
| [::first-line](https://www.w3school.com.cn/cssref/selector_first-line.asp) | p::first-line   | 选择每个 <p> 元素的首行。     |
| [::selection](https://www.w3school.com.cn/cssref/selector_selection.asp) | p::selection    | 选择用户选择的元素部分。      |

- 伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。

#####  CSS 伪类

| 选择器                                                       | 例子           | 描述                                        |
| ------------------------------------------------------------ | -------------- | ------------------------------------------- |
| [:active](https://www.w3school.com.cn/cssref/selector_active.asp) | a:active       | 选择活动的链接。                            |
| [:hover](https://www.w3school.com.cn/cssref/selector_hover.asp) | a:hover        | 选择鼠标悬停其上的链接。                    |
| [:visited](https://www.w3school.com.cn/cssref/selector_visited.asp) | a:visited      | 选择所有已访问的链接。                      |
| [:nth-child(*n*)](https://www.w3school.com.cn/cssref/selector_nth-child.asp) | p:nth-child(2) | 选择作为其父的第二个子元素的每个 <p> 元素。 |
| [:checked](https://www.w3school.com.cn/cssref/selector_checked.asp) | input:checked  | 选择每个被选中的 <input> 元素。             |

**总结：**

1. **伪元素用于设置元素指定部分的样式** 如设置元素首字母，首行样式；在元素前后插入内容
2. **伪类用于设置元素的特殊状态、**如鼠标经过效果、某个元素获得焦点时的效果，是**针对已有的元素**设置的

### 12. 对 requestAnimationframe 的理解

​	实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是**请求动画帧**。

MDN对该方法的描述：

>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

**语法：** `window.requestAnimationFrame(callback);`  其中，callback是**下一次重绘之前更新动画帧所调用的函数**(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于 **宏任务**，所以会在执行完微任务之后再执行。

**取消动画：**使用`cancelAnimationFrame()`来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。

**优势：**

- **CPU节能**：使用 SetInterval 实现的动画，当页面被隐藏或最小化时，SetInterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用的状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处于未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。
- **函数节流：**在高频率事件（resize，scroll等）中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次是没有意义的，因为多数显示屏每16.7ms刷新一次，多次刷新并不会在屏幕上体现出来。
- **减少 DOM 操作：**requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。

**setTimeout执行动画的缺点**：它通过设定间隔时间来不断改变图像的位置，达到动画效果，但是容易出现卡顿、抖动的现象；原因是：

- setTimeout 任务被放入异步队列，只有当主线任务执行完后才会执行任务队列中的任务，因此实际执行时间总比设定时间要晚
- setTimeout 的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。

```js
var element = document.getElementById('animate');
element.style.position = 'absolute';

var start = null;

function step(timestamp) {
  if (!start) start = timestamp;
  var progress = timestamp - start;
  // 元素不断向左移，最大不超过200像素
  element.style.left = Math.min(progress / 10, 200) + 'px';
  // 如果距离第一次执行不超过 2000 毫秒，
  // 就继续执行动画
  if (progress < 2000) {
    window.requestAnimationFrame(step);
  }
}

window.requestAnimationFrame(step);
```

### 13.为什么有时候⽤ **translate** 来改变位置⽽不是定位？

1. **性能优化：** `translate` 操作通常比定位操作更加高效。使用 `translate` 不会触发浏览器的重排和重绘，因此在动画或实时变化的元素上使用 `translate` 可以提高性能，特别是在移动设备上。
2. **硬件加速：** 使用 `translate` 可以利用硬件加速，因此在移动设备上表现更流畅。一些浏览器和设备会针对使用 `translate` 的元素进行优化，而不会对使用定位的元素进行同样的优化。
3. **元素层叠：** 使用定位属性（如 `position: absolute` 或 `position: relative`）可能会影响元素的层叠顺序，而 `translate` 不会改变元素的层叠顺序。这意味着使用 `translate` 可以更容易地控制元素的堆叠顺序，避免一些意外的问题。

总的来说，虽然定位属性可以实现类似的效果，但在性能和可维护性上，使用 `translate` 通常是更好的选择，特别是在需要进行动画或实时变化的情况下。

### 14. CSS3中有哪些新特性

- 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）
- 圆角 （border-radius:8px）
- 多列布局 （multi-column layout）
- 阴影和反射 （Shadow eflect）
- 文字特效 （text-shadow）
- 文字渲染 （Text-decoration）
- 线性渐变 （gradient）
- 旋转 （transform）
- 增加了旋转,缩放,定位,倾斜,动画,多背景

### 15. 对 CSSSprites 的理解

CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。

**优点：**

- 利用`CSS Sprites`能很好地减少网页的http请求，从而大大提高了页面的性能，这是`CSS Sprites`最大的优点；
- `CSS Sprites`能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。

**缺点：**

- 在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；
- `CSSSprites`在开发的时候相对来说有点麻烦，需要借助`photoshop`或其他工具来对每个背景单元测量其准确的位置。
- 维护方面：`CSS Sprites`在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的`CSS`，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动`CSS`。

### 16. CSS 优化和提高性能的方法有哪些？

**加载性能：**

（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。

（2）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。

（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。

**选择器性能：**

（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；

（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。

（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。

（4）尽量少的去对标签进行选择，而是用class。

（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。

（6）解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。

**渲染性能：**

（1）慎重使用高性能属性：浮动、定位。

（2）尽量减少页面重排、重绘。

（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。

（4）属性值为0时，不加单位。

（5）属性值为浮动小数0.**，可以省略小数点之前的0。

（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。

（7）不使用@import前缀，它会影响css的加载速度。

（8）选择器优化嵌套，尽量避免层级过深。

（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。

（10）正确使用`display`的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。

（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。

**可维护性、健壮性：**

（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。

（2）样式与内容分离：将css代码定义到外部css中。

### 17.  CSS预处理器 / 后处理器是什么？为什么要使用它们？

**预处理器，**如：less、sass、stylus，用来预编译 sass 或者 less，增加了 css 代码的复用性。层级，mixin，变量，循环，函数等对编写以及开发 UI 组件都极为方便。

**后处理器，**如：postCss，通常是在完成的样式表中根据 css 规范处理 css，让其更加有效。目前最长做的是给 css 属性添加浏览器私有前缀，实现跨浏览器兼容的问题。

`css`预处理器为`css`增加一些编程特性，无需考虑浏览器的兼容问题，可以在`CSS`中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让`css`更加的简洁，增加适应性以及可读性，可维护性等。

其它`css`预处理器语言：`Sass（Scss）`, `Less`, `Stylus`, `Turbine`, `Swithch css`, `CSS Cacheer`, `DT Css`。

使用原因：

- 结构清晰， 便于扩展
- 可以很方便的屏蔽浏览器私有语法的差异
- 可以轻松实现多重继承
- 完美的兼容了`CSS`代码，可以应用到老项目中

### 18. 对 CSS工程化的理解

CSS 工程化是为了解决以下问题：

1. **宏观设计**：CSS 代码如何组织、如何拆分、模块结构怎样设计？
2. **编码优化**：怎样写出更好的 CSS
3. **构建**：如何处理我的 CSS，才能让它的打包结果最优？
4. **可维护性**：代码写完了，如果最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？

以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：

- 预处理器：Less、Sass 等
- 重要的工程化插件：PostCss；
- Webpack、loader 等

基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：

**（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？**

预处理器，其实就是 CSS 世界的 “轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码：

> 类 CSS 代码 ===》 预处理器 ===》CSS 代码

那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：

1. 宏观设计上：我们希望能够优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；
2. 编码优化上：我们希望能够写出结构清晰、简明易懂的 CSS,需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性。这样我们可以少写一些无用的代码
3. 可维护性：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。

这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：

- 嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；
- 支持定义 css 变量
- 提供计算函数
- 允许对代码片段进行 extend 和 mixin
- 支持循环语句的使用
- 支持将 CSS 文件模块化，实现复用

**2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？**

PostCss 仍然是一个对 CSS 进行解析和处理的工具，它会对 CSS 做这样的事情：

>旧的CSS代码 ==》PostCss ==》新的CSS代码

它和预处理器的不同在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高配版本的 JS  转为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。

PostCss 在业务中的使用场景非常多：

- 提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；
- 当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 [Autoprefixer](https://github.com/postcss/autoprefixer) 插件可以帮助我们自动增加浏览器前缀；
- 允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；

**（3）Webpack 能处理 CSS 吗？如何实现？**

Webpack 能处理 CSS 吗：

- **Webpack 在裸奔的状态下，是不能处理 CSS 的**，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；
- Webpack 在 loader 的辅助下，是可以处理 CSS 的。

如何用 Webpack 实现对 CSS 的处理：

- Webpack 中操作 CSS 需要使用的两个关键的 loader：**css-loader** 和 **style-loader**
- 注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：

- - css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；
  - style-loader：创建style标签，把 CSS 内容写入标签。

在实际使用中，**css-loader 的执行顺序一定要安排在 style-loader 的前面**。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。

### 19. 常见的 CSS 布局单位

常用的布局单位包括像素（`px`），百分比（`%`），`em`，`rem`，`vw/vh`。

**（1）像素**（`px`）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：

- **CSS像素**：为web开发者提供，在CSS中使用的一个抽象单位；
- **物理像素**：只与设备的硬件密度有关，任何设备的物理像素都是固定的。

**（2）百分比**（`%`），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。

**（3）em和rem**相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：**em相对于最近的父元素，rem相对于根元素。**

- **`em` 单位**：相对于其最近的父元素的字体大小。这种相对单位使得字体大小和元素尺寸可以根据父元素的大小进行调整，这在某些情况下是非常有用的，例如在设计响应式布局时。
- **`rem` 单位**：相对于根元素（`<html>` 元素）的字体大小。这种相对单位可以让开发者更加方便地控制整个页面的字体大小，因为只需要在根元素中设置一个基准值即可，而不用考虑到不同元素的层级关系。

**（4）vw/vh**是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。

- vw：相对于视窗的宽度，视窗宽度是100vw；
- vh：相对于视窗的高度，视窗高度是100vh；
- vmin：vw和vh中的较小值；
- vmax：vw和vh中的较大值；

**vw/vh** 和百分比很类似，两者的区别：

- 百分比（`%`）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)
- vw/vm：相对于视窗的尺寸

### 20.BFC（块级格式化上下文）

#### 1). BFC 是什么？

- **块级格式化上下文**：是一个独立的渲染区域，具有一定的布局规则，内部的元素按照一定的规则进行布局。
- **独立性**：BFC 内部的元素不会影响到外部元素的布局，外部元素也不会影响到 BFC 内部元素的布局。

#### 2). 触发 BFC 的条件：

- **根元素**（HTML）或者具有 `float`、`overflow`（除了 `visible`）、`display`（值为 `table-cell`、`table-caption`、`table`、`inline-block` 中的任意一个）属性的元素会触发 BFC。
- 元素处于 BFC 中，可以通过设置 `overflow` 属性为除 `visible` 以外的值，来触发 BFC。

#### 3). BFC 的特性：

- **内部的块级盒子会垂直地一个接一个地放置**，块级元素在 BFC 中按照正常的文档流排列，从上到下。
- **相邻的两个块级盒子之间的垂直外边距会重叠**，但是在不同的 BFC 中的元素之间的外边距不会发生重叠。
- **BFC 区域不会与浮动元素的盒子重叠**，浮动的元素不会影响 BFC 区域的尺寸，反之亦然。
- **BFC 可以包含浮动的子元素**，在 BFC 中的元素会像浮动元素不存在一样进行布局。

#### 4). BFC 的应用场景：

- **解决高度塌陷的问题**：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置`overflow:hidden`。
- **避免外边距重叠**：通过触发 BFC 避免相邻元素外边距的重叠。
- **创建多栏布局**：利用 BFC 特性实现两栏或多栏布局，确保布局的稳定性和可靠性。

### 21.两栏布局的实现

一般两栏布局指的是**左边一栏宽度固定，右边一栏宽度自适应**，两栏布局的具体实现：

- 利用浮动，将左边元素宽度设置为 200px，并设置向左浮动，将右边的元素 margin-left 设置为200px，宽度设置为 auto（默认为auto，撑满整个父元素）

```css
<div class="left outer"></div>
<div class="right outer"></div>
.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  background-color: tomato;
}
.right {
  margin-left: 200px;
  width: auto;
  background-color: gold;
}
```

- 利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。

```CSS
<div class="left"></div>
<div class="right"></div>
.left {
    width: 100px;
    height: 200px;
    background: red;
    float: left;
}
.right {
    height: 300px;
    background: blue;
    overflow: hidden;
}
```

- 利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。

```css
<div class="outer">
    <div class="left"></div>
    <div class="right"></div>
</div>
.outer {
    display: flex;
    height: 100px;
}
.left {
    width: 200px;
    background: red;
}
.right {
    flex: 1;
    background: blue;
}
```

- 利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。

```css
<div class="outer">
    <div class="left"></div>
    <div class="right"></div>
</div>
.outer {
  position: relative;
  height: 100px;
}
.left {
  position: absolute;
  width: 200px;
  height: 100px;
  background: tomato;
}
.right {
  margin-left: 200px;
  background: gold;
}
```

### 22.三栏布局的实现

三栏布局一般指的是页面中一共有三栏，**左右两栏宽度固定，中间自适应的布局**，三栏布局的具体实现：

- 利用**绝对定位**，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。

```css
<div class="outer">
    <div class="left"></div>
    <div class="center"></div>
    <div class="right"></div>
</div>
.left {
    position: absolute;
    width: 100px;
    height: 100px;
    background: tomato;
}
.right {
    position: absolute;
    top: 0;
    right: 0;
    width: 200px;
    height: 100px;
    background: gold;
}
.center {
    margin-left: 100px;
    margin-right: 200px;
    height: 100px;
    background: lightgreen;
}
```

- 利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。

```css
<div class="outer">
    <div class="left"></div>
    <div class="center"></div>
    <div class="right"></div>
</div>
.outer {
  display: flex;
  height: 100px;
}
.left {
  width: 100px;
  background: tomato;
}
.right {
  width: 100px;
  background: gold;
}
.center {
  flex: 1;
  background: lightgreen;
}
```

- 利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式**，中间一栏必须放到最后：**因为浮动的元素脱离的正常文档流

```css
<div class="outer">
    <div class="left"></div>
    <div class="right"></div>
    <div class="center"></div>
</div>
.outer {
  height: 100px;
}
.left {
  float: left;
  width: 100px;
  height: 100px;
  background: tomato;
}
.right {
  float: right;
  width: 200px;
  height: 100px;
  background: gold;
}
.center {
  height: 100px;
  margin-left: 100px;
  margin-right: 200px;
  background: lightgreen;
}
```

### 23.常见的水平垂直居中

- 最简单的方案 flex布局

  ```css
  .father {
      display:flex;
      justify-content:center;
      align-items: center;
  }
  .son {
      ...
  }
  ```

- 绝对定位配合margin:auto，实现

  ```css
  .father {
      position: relative;
  }
  .son {
      position: absolute;
      top:0;
      left:0;
      bottom: 0;
      right:0;
      margin: auto;
  }
  ```

- 绝对定位配合transform实现

  ```css
  .father {
      position: relative;
  }
  .son {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%)
  }
  ```

### 24.什么是margin重叠问题？如何解决？

**问题描述：**

两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，**浮动的元素和绝对定位**这种脱离文档流的元素的外边距不会合并。重叠只会出现在**垂直方向**。

**计算原则：**

折叠合并后外边距的计算原则如下：

- 如果两者都是正数，那么就取最大者
- 如果一正一负，就会正值减去负值的绝对值
- 两个都是负值时，用0减去两个中绝对值大的那个

**解决办法：**

对于折叠的情况，主要有两种：**兄弟之间重叠**和**父子之间重叠**

（1）兄弟之间重叠

- 底部元素变为行内盒子：`display：inline-block`
- 底部元素设置浮动：float
- 底部元素的 position 的值为 absolute/fixed

（2）父子之间重叠

- 父元素加入：`overflow-hidden`
- 父元素添加透明边框：border:1px solid transparent
- 子元素变为行内盒子：display：inline-block
- 子元素加入浮动属性或定位

### 25、position的属性

position是CSS中用来控制元素定位的属性，有以下几种取值：

| 属性值   | 概述                                                         |
| -------- | ------------------------------------------------------------ |
| absolute | 绝对定位，元素相对于其最近的一个**已定位的祖先元素**进行定位，如果没有已定位的祖先元素，则相对于**<html>元素**。通过top、right、bottom、left属性来设置位置 |
| relative | 相对定位，元素相对于其**自身在文档流中的位置**进行定位，通过top、right、bottom、left属性来调整位置 |
| fixed    | 固定定位，元素相对于浏览器窗口进行定位，即使页面滚动，元素也会保持固定位置。也是通过top、right、bottom、left属性来设置位置。 |
| static   | 默认值，元素遵循正常文档流，不会被特殊定位。                 |
| sticky   | 粘性定位，元素在跨越特定阈值前为相对定位，之后为固定定位。通过top、right、bottom、left属性来设置固定位置的阈值。 |

`position: sticky` 和 `position: fixed` 都是用来实现元素的固定定位，但它们之间有一些重要的区别：

`position: fixed`：

1. 元素固定在浏览器窗口中的某个位置，即使页面滚动，元素也会保持在固定位置。
2. 元素的定位参考是视口（viewport），而不是任何父元素。
3. 在移动端设备和一些旧的浏览器上可能会出现性能问题，因为固定定位的元素需要在滚动时进行实时的重新渲染。

`position: sticky`：

1. 元素在滚动时表现为普通定位，直到它滚动到特定的位置，然后会变为固定定位，直到它的父容器结束。
2. 元素会在父容器内固定，而不是在视口中固定。
3. 具有粘性定位的元素会在滚动时表现得更加平滑，因为它只有在特定条件下才会变为固定定位元素，这有助于减少页面重绘和重新渲染的频率。

总的来说，`position: fixed` 是将元素固定在视口中的某个位置，而 `position: sticky` 则在滚动到特定位置时，会固定在父容器内部。`position: sticky` 可以提供更好的性能和使用体验，但是需要根据具体的布局需求进行选择。

```html
<style>
    .header {
        position: -webkit-sticky;
        /* Safari */
        position: sticky;
        top: 0;
        background-color: #f1f1f1;
        padding: 10px;
        margin-top: 120px;
    }

    .content {
        height: 2000px;
        /* 为了拉长内容区域 */
    }
</style>

<body>
	<div class="header">
		<p>我是一个吸顶元素</p>
	</div>
	<div class="content">
		<p>这是内容区域</p>
	</div>
</body>
```

### 26.CSS中的颜色HSL

HSL（Hue, Saturation, Lightness）是一种颜色模型，它使用色调、饱和度和明度三个参数来表示颜色。

- **色调（Hue）**：色调是指颜色的基本颜色，比如红色、橙色、黄色、绿色、蓝色、靛色和紫色。色调用角度表示，范围从 0° 到 360°。0° 为红色，120° 为绿色，240° 为蓝色。
- **饱和度（Saturation）**：饱和度是指颜色的强度或纯度。饱和度越高，颜色越鲜艳；饱和度越低，颜色越灰暗。饱和度用百分比表示，范围从 0% 到 100%。0% 为灰色，100% 为完全饱和的颜色。
- **明度（Lightness）**：明度是指颜色的亮度或暗度。明度越高，颜色越亮；明度越低，颜色越暗。明度用百分比表示，范围从 0% 到 100%。0% 为黑色，100% 为白色。

**HSL 用法**

HSL 可以用以下方式表示：

```
hsl(色调, 饱和度, 明度)
```

例如，以下代码表示一个鲜艳的红色：

```
hsl(0, 100%, 50%)
```

以下代码表示一个暗淡的蓝色：

```
hsl(240, 50%, 25%)
```

HSL 可以用在 CSS、HTML 和 SVG 中来指定颜色。

**CSS**

```css
body {
  background-color: hsl(0, 100%, 50%);
}
```

**HTML**

```html
<div style="background-color: hsl(0, 100%, 50%);">
  Hello world!
</div>
```

**SVG**

```svg
<rect width="100" height="100" fill="hsl(0, 100%, 50%)" />
```

### 27.场景应用

#### 1）实现一个三角形

CSS绘制三角形主要用到的是border属性，也就是边框。

平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：

```css
div {
    width: 0;
    height: 0;
    border: 100px solid;
    border-color: orange blue red green;
}
```

将元素的长宽都设置为0，显示出来的效果是这样的：

<img src="C:\Users\TW0069768\Desktop\gitHub\notes\面试总结\border100px.png" alt="image-20240424172410313" style="zoom:40%;" />

所以可以根据border这个特性来绘制三角形：箭头向左的三角形

```css
div {
    width: 0;
    height: 0;
    border-right: 50px solid red;
    border-top: 50px solid transparent;
    border-bottom: 50px solid transparent;
}
```

#### 2）实现一个扇形

```css
div{
    border: 100px solid transparent;
    width: 0;
    height: 0;
    border-radius: 100px;
    border-top-color: red;
}
```

#### 3) 实现一个圆和半圆

##### 圆

```css
div {
  background-color: red;
  height: 100px;
  width: 100px;
  border-radius: 50%;
}
```

##### 半圆

左半圆

```css
div{
    background-color: red;
    height: 100px;
    width: 50px;
    border-radius: 50px 0px 0px 50px;
}
```

右半圆

```css
div{
    background-color: red;
    height: 100px;
    width: 50px;
    border-radius: 0px 50px 50px 0px;
}
```

上半圆

```css
div{
    background-color: red;
    height: 50px;
    width: 100px;
    border-radius: 50px 50px 0px 0px;
}
```

下半圆

```css
div{
    background-color: red;
    height: 50px;
    width: 100px;
    border-radius: 0px 0px 50px 50px;
}
```

#### 4)画一个梯形

直角梯形

```css
div{
    height: 0;
    width: 100px;
    border-bottom: 100px solid red;
    border-right: 40px solid transparent;
}
```

等腰梯形

```css
div{
    height: 0;
    width: 100px;
    border-width: 0 40px 100px 40px;
    border-style: solid;
    border-color: transparent transparent red;
}
```

#### 5) 设置小于 12px 的字体

在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。

**解决办法：**

- 使用 Webkit 的内核的 -webkit-text-size-adjust 的私有CSS属性来解决，只要加了 -webkit-text-size-adjust: none; 字体大小就不受控制了。但是 Chrome 更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。
- 使用 css3 的 transform 缩放属性 -webkit-transform:scale(0.5);注意 -webkit-transform：scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用 display：block/inline-block/...

## 三、JavaScript

## 1. 数据类型

### 1）JavaScript 有哪些数据类型，它们的区别？

JavaScript总共有八种数据类型，分别是 Number、String、Boolean、Null、Undefined、Object、Symbol、BigInt

其中 Symbol 和 BigInt 是ES6新增的数据类型

- Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。

typeof 能识别所有的值类型，识别函数，能区分是否是引用类型。

- BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。

这些数据可以分为原始数据类型和引用数据类型：

- 栈：原始数据类型（Undefined、Null、Boolean、Number、String）
- 堆：引用数据类型（对象、数组和函数）

```js
typeof "123" ==> str        typeof 123  ==> number    typeof BigInt(9007199254740991) ==> bigint
typeof false  ==> boolean   typeof undefined ==> undefined  typeof ()=>{}  ==> function
typeof null ==> object     typeof []  ==> object      typeof  Symbol("f") ==> symbol
```

`instanceof`用于检测构造函数的`prototype`属性是否出现在某个实例对象的原型链上。

### 2）数据类型检测的方法

#### 2.1 typeof

```js
console.log(typeof 2);               // number
console.log(typeof true);            // boolean
console.log(typeof 'str');           // string
console.log(typeof []);              // object    
console.log(typeof function(){});    // function
console.log(typeof {});              // object
console.log(typeof undefined);       // undefined
console.log(typeof null);            // object
```

其中数组、对象、null 都会被 判断为Object。

#### 2.2 instanceof

instanceof 可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型

```js
console.log(2 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false 
console.log('str' instanceof String);                // false 
 
console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true
```

可以看到，`instanceof`**只能正确判断引用数据类型**，而不能判断基本数据类型。`instanceof` 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 `prototype` 属性。

#### 2.3 constructor

```js
console.log((2).constructor === Number); // true
console.log((true).constructor === Boolean); // true
console.log(('str').constructor === String); // true
console.log(([]).constructor === Array); // true
console.log((function() {}).constructor === Function); // true
console.log(({}).constructor === Object); // true
//使用括号括起来是为了确保 .constructor 属性能够正确地应用在对象上
```

constructor有两个作用，一是判断数据类型，二是对象实例通过 constructor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了：

```js
function fn()
Fn.prototype = new Array();
var f = new Fn()

console.log(f.constructor === Fn)   //false
console.log(f.constructor === Array)//true
```

#### 2.4 Object.prototype.toString.call()

**Object.prototype.toString.call()** 使用Object对象的原型方法 toString 来判断数据类型：

```js
var a = Object.prototype.toString;
 
console.log(a.call(2));                   //[object Number]
console.log(a.call(true));                //[object Boolean]
console.log(a.call('str'));               //[object String]
console.log(a.call([]));                  //[object Array]
console.log(a.call(function(){}));                //[object Boolean]
console.log(a.call({}));                //[object Boolean]
console.log(a.call(undefined));                //[object Boolean]
console.log(a.call(null));                //[object Boolean]
```

同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？

这是因为toString是Object的原型方法，而Array、function等**类型作为Object的实例，都重写了toString方法**。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。

### 3）判断数组的方式有哪些

- 通过Object.prototype.toString.call() 做判断

  ```js
  Object.prototype.toString.call(obj).slice(8,-1) === 'Array';
  // 具体来说，假设 Object.prototype.toString.call(obj) 返回的字符串是 '[object Array]'，那么.slice(8, -1) 将提取出 Array 这部分字符串。
  // 这样就可以与 'Array' 进行比较，从而确定对象是否为数组。
  ```

- 通过原型链做判断

  ```js
  obj.__proto__ === Array.prototype;
  //在 JavaScript 中，obj.__proto__ 用于获取对象的原型，而 Array.prototype 是数组的原型。因此，如果一个对象的原型链指向了 Array.prototype，那么这个对象就被认为是数组的一个实例。
  ```

- 通过ES6的Array.isArray()做判断

  ```js
  Array.isArrray(obj);
  ```

- 通过instanceof做判断

  ```js
  obj instanceof Array
  // 它通过检查对象的原型链来确定对象是否是特定构造函数的实例
  ```

- 通过Array.prototype.isPrototypeOf

  ```js
  Array.prototype.isPrototypeOf(obj)
  //Array.prototype.isPrototypeOf(obj) 是 JavaScript 中的一个方法，用于检查 Array.prototype 是否位于对象 obj 的原型链上。
  
  //如果 Array.prototype 在 obj 的原型链上，则返回 true，否则返回 false。这意味着，如果 obj 是一个数组或者是由数组派生出来的对象，那么这个方法会返回 true。
  
  //这个方法在一些情况下可能会用到，但通常情况下，直接使用 Array.isArray() 方法更为简洁和清晰。
  ```

### 4） intanceof 操作符的实现原理及实现

`instanceof` 操作符用于检查一个对象是否是一个构造函数的实例，或者说是否是由该构造函数创建的。它的实现原理主要是通过检查对象的原型链是否包含构造函数的原型。

实现 `instanceof` 操作符的一种常见方式是：

1. 首先，获取对象的原型链。
2. 然后，从对象的原型链上逐级向上查找，直到找到与给定构造函数的 `prototype` 属性相等的原型对象，或者到达原型链的顶端（`null`）。
3. 如果找到相等的原型对象，则返回 `true`，表示对象是该构造函数的实例；如果找不到，则返回 `false`。

以下是一个简单的 JavaScript 实现示例：

```js
function myInstanceof(obj, constructor) {
    // 判断输入是否合法
    if (typeof constructor !== 'function') {
        throw new TypeError('Right-hand side of instanceof is not callable');
    }
    // 获取对象的原型链
    let proto = Object.getPrototypeOf(obj)
    
    // 逐级向上查找原型链，直到找到与构造函数的原型相等的原型对象或者到达顶端（null）
    while (proto !== null) {
        if (proto === constructor.prototype) {
            return true
        }
        proto = Object.getPrototypeOf(proto)
    }
    return false;
}
// 示例
function Person() {}
const obj = new Person();
console.log(myInstanceof(obj, Person)); // true
console.log(myInstanceof(obj, Object)); // true，因为所有对象都是 Object 的实例
console.log(myInstanceof(obj, Array)); // false
```

### 5）为什么0.1+0.2 ! == 0.3，如何让其相等  

```js
let n1 = 0.1, n2 = 0.2
console.log(n1 + n2)  // 0.30000000000000004
```

这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：

```js
(n1 + n2).toFixed(2) // 注意，toFixed为四舍五入
```

`toFixed(num)` 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？

计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是`0.0001100110011001100...`（1100循环），0.2的二进制是：`0.00110011001100...`（1100循环），这两个数的二进制都是无限循环的数。

### 6）typeof NaN 的结果是什么？

NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。

```js
typeof NaN; // "number"
```

### 7）isNaN 和 Number.isNaN 函数的区别？

- 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。
- 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。

### 8）数组的forEach和map方法有哪些区别？常用哪些方法对数组进行增、删、改

- forEach是对数组的每一个元素执行一次给定的函数。
- map是创建一个新数组，该新数组由原数组的每个元素都调用一次提供的函数返回的值。
- pop()：删除数组后面的最后一个元素，返回值为**被删除的**那个元素
- push()：将一个元素或多个元素添加到数组末尾，并返回**新的长度**。
- shift()：删除数组中的第一个元素，并返回被删除元素的值。
- unshift()：将一个或多个元素添加到数组的**开头**，并返回该数组的**新长度**。
- splice()：通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容
- reverse()：反转数组。

```js
const arr = [1,2,3,4,5,6]
arr.forEach(x => {
    x = x +1 ;
    console.log(x);
});
// x :>>  2
// x :>>  3
// x :>>  4
// x :>>  5
// x :>>  6
// x :>>  7
console.log(arr);
//[ 1, 2, 3, 4, 5, 6 ]

const mapArr = arr.map(x => {
    x = x*2;
    return x;
});
console.log("mapArr :>> ", mapArr); // [ 2, 4, 6, 8, 10, 12 ]
console.log("arr :>> ", arr); //  [ 1, 2, 3, 4, 5, 6 ]

const popArr = arr.pop();
console.log("popArr :>> ", popArr); // popArr :>>  6
console.log("arr :>> ", arr); // arr :>>  [ 1, 2, 3, 4, 5 ]

const pushArr = arr.push("a");
console.log("pushArr :>> ", pushArr); // pushArr :>>  6
console.log("arr :>> ", arr); // arr :>>  [ 1, 2, 3, 4, 5, 'a' ]

const shiftArr = arr.shift();
console.log("shiftArr :>> ", shiftArr); // shiftArr :>>  1
console.log("arr :>> ", arr); // arr :>>  [ 2, 3, 4, 5, 'a' ]

const unshiftArr = arr.unshift("b", "c");
console.log("unshiftArr :>> ", unshiftArr); // unshiftArr :>>  7
console.log("arr :>> ", arr); // arr :>>  ['b', 'c', 2,3,4,5,'a']

const spliceArr = arr.splice(2, 4, "d", "e");// 从第2个开始，截取4个，然后添加两个"d"、"e"
console.log("spliceArr :>> ", spliceArr); // spliceArr :>>  [ 2, 3, 4, 5 ]
console.log("arr :>> ", arr); // arr :>>  [ 'b', 'c', 'd', 'e', 'a' ]

const reverseArr = arr.reverse();
console.log("reverseArr :>> ", reverseArr); // reverseArr :>>  [ 'a', 'e', 'd', 'c', 'b' ]
console.log("arr :>> ", arr); // arr :>>  [ 'a', 'e', 'd', 'c', 'b' ]
console.log("reverseArr === arr :>> ", reverseArr === arr); // reverseArr === arr :>>  true
```

## 2.ES6

### 1）let、const、var的区别

**（1）块级作用域：**块作用域由 `{ }`包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：

- 内层变量可能覆盖外层变量
- 用来计数的循环变量泄露为全局变量

**（2）变量提升：**var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。

**（3）给全局添加属性：**浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。

**（4）重复声明：**var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。

**（5）暂时性死区：**在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为**暂时性死区**。使用var声明的变量不存在暂时性死区。

**（6）初始值设置：**在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。

**（7）指针指向：**let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。

### 2）const 对象的属性可以修改吗

const 保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。

但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。

### 3）实现一个类似关键字new功能的函数

在js中new关键字主要做了：首先创建一个空对象，这个对象会作为执行new构造函数之后返回的对象实例，将创建的空对象原型（`__proto__`）指向构造函数的prototype属性，同时将这个空对象赋值给构造函数内部的this，并执行构造函数逻辑，根据构造函数的执行逻辑，返回初始创建的对象或构造函数的显示返回值。

new 操作符的实现步骤如下：

1. 创建一个对象
2. 将构造函数的作用域赋给新对象（也就是将对象的 `__protp__`属性指向构造函数的prototype属性）
3. 指向构造函数中的代码，构造函数中的this指向该对象（也就是为了这个对象添加属性和方法）
4. 返回新的对象

```js
function newFn(...args) {
    const constructor = args.shift();
    const obj = Object.create(constructor.prototype);
    const result = constructor.apply(obj, args);
    return typeof result === "object" && result !== null ? result : obj;
}
function Person(name) {
    this.name = name;
}

const p = newFn(Person, "JOM");
console.log( p.name); //   JOM
```

### 4）箭头函数与普通函数的区别

#### （1）箭头函数比普通函数更加简洁

- 如果没有参数，就直接写一个空括号即可

- 如果只有一个参数，可以省去参数的括号

- 如果有多个参数，用逗号分隔

- 如果函数体的返回值只有一句，可以省略大括号

- 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：

  ```js
  let fn = () => void doesNotReturn()
  ```

####  （2）箭头函数没有自己的this

​	箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。

####  （3）箭头函数继承来的this指向永远不会改变

```js
var id = 'GLOBAL'
var obj = {
    id:'OBJ',
    a:function(){
        console.log(this.id)
    },
    b:() => {
        console.log(this.id)
    }
}
obj.a();    // 'OBJ'
obj.b();    // 'GLOBAL'
new obj.a()  // undefined
new obj.b()  // Uncaught TypeError: obj.b is not a constructor
```

对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号`{}`是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。

####  （4）call()、apply()、bind()等方法不能改变箭头函数中this的指向

```js
var id = 'Global';
let fun1 = () => {
    console.log(this.id)
};
fun1();                     // 'Global'
fun1.call({id: 'Obj'});     // 'Global'
fun1.apply({id: 'Obj'});    // 'Global'
fun1.bind({id: 'Obj'})();   // 'Global'
```

####   （5）箭头函数不能作为构造函数使用

​	构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。

####   （6）箭头函数没有自己的arguments

​	箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。

####    （7）箭头函数没有prototype

####    （8）箭头函数不能用作Generator函数，不能使用yeild关键字

```js
this.id = "global";

console.log("this.id :>> ", this.id); // this.id :>>  global

function normalFun() {
    return this.id;
}

const arrowFun = () =>{
    return this.id;
};

const newNormal = new normalFun();
console.log("newNormal :>> ", newNormal); // newNormal :>>  normalFun {}
try{
    const newArr = new arrowFun();
} catch (error) {
    console.log("error :>> ", error); // error :>>  TypeError: arrowFun is not a constructor
// 出错原因：arrowFun不是一个构造函数，因此无法使用new关键字创建其实例。在js中箭头函数使用箭头(=>)语法定义的函数，它具有一些特殊行为和限制。与普通函数不同，箭头函数没有自己的this绑定。相反，它使用词法作用域中的this值，即它继承自包含它的代码块上下文。相反，普通函数具有自己的this绑定，可以通过new关键字进行实例化。normalFun是一个普通函数，可以使用new关键字创建它的实例。
}
```

### 5）箭头函数的this指向哪里？

箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。

可以⽤Babel理解⼀下箭头函数:

```js
// ES6 
const obj = { 
  getArrow() { 
    return () => { 
      console.log(this === obj); 
    }; 
  } 
}
```

转化后：

```js
// ES5，由 Babel 转译
var obj = { 
   getArrow: function getArrow() { 
     var _this = this; 
     return function () { 
        console.log(_this === obj); 
     }; 
   } 
};
```

### 6）扩展运算符的作用及使用场景

1. 对象扩展运算符

   对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。

   ```js
   let bar = { a:1, b:2 }
   let baz = { ...bar }; // { a:1, b:2 }
   ```

   上述方法实际上等价于:

   ```js
   let bar = { a:1, b:2 }
   let baz = Object.assign({}, bar); // { a: 1, b: 2 }
   ```

   `Object.assign` 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。`Object.assign` 方法的第一个参数是目标对象，后面的参数都是源对象。(**如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性**)。

   同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。

   ```js
   let bar = {a: 1, b: 2};
   let baz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}
   ```

   利用上述特性就可以很方便的修改对象的部分属性。

   需要注意：**扩展运算符对对象实例的拷贝属于浅拷贝**。

2. 数组扩展运算符

   数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。

   ```js
   console.log(...[1, 2, 3])
   // 1 2 3
   console.log(...[1, [2, 3, 4], 5])
   // 1 [2, 3, 4] 5
   ```

   下面是数组的扩展运算符的应用：

   - **将数组转换为参数序列**

     ```js
     function add(x, y) {
       return x + y;
     }
     const numbers = [1, 2];
     add(...numbers) // 3
     ```

   - **复制数组**

     ```js
     const arr1 = [1, 2];
     const arr2 = [...arr1];
     ```

     要记住：**扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中**，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。

   - **合并数组**

     如果想在数组内合并数组，可以这样：

     ```js
     const arr1 = ['two', 'three'];
     const arr2 = ['one', ...arr1, 'four', 'five'];
     // ["one", "two", "three", "four", "five"]
     ```

   - **扩展运算符与解构赋值结合起来，用于生成数组**

     ```js
     const [first, ...rest] = [1, 2, 3, 4, 5];
     first // 1
     rest  // [2, 3, 4, 5]
     ```

     需要注意：**如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。**

   - **将字符串转为真正的数组**

     ```js
     [...'hello']    // [ "h", "e", "l", "l", "o" ]
     ```

   - **任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组**

     比较常见的应用是可以将某些数据结构转为数组：

     ```js
     // arguments对象
     function foo() {
       const args = [...arguments];
     }
     ```

     用于替换`es5`中的`Array.prototype.slice.call(arguments)`写法。

   - **使用**`Math`**函数获取数组中特定的值**

     ```js
     const numbers = [9, 4, 7, 1];
     Math.min(...numbers); // 1
     Math.max(...numbers); // 9
     ```

### 7）对对象和数组的解构的理解

解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。

1. **数组的解构**

   在解构数组时，以元素的位置为匹配条件来提取想要的数据的：

   ```js
   const [a, b, c] = [1, 2, 3]
   ```

   通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：

   ```js
   const [a,,c] = [1,2,3]
   ```

2. **对象的解构**

   对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：

   ```js
   const stu = {
     name: 'Bob',
     age: 24
   }
   ```

   假如想要解构它的两个自有属性，可以这样：

   ```js
   const { name, age } = stu
   ```

   这样就得到了 name 和 age 两个和 stu 平级的变量：

   ```js
   name "Bob"
   age 24
   ```

### 8）如何提取高度嵌套的对象里的指定属性

有时会遇到一些嵌套程度非常深的对象：

```js
const school = {
   classes: {
      stu: {
         name: 'Bob',
         age: 24,
      }
   }
}
```

像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：

```js
const { name } = school
```

显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：

```js
const { classes } = school
const { stu } = classes
const { name } = stu
name // 'Bob'
```

但是还有一种更标准的做法，可以用一行代码来解决这个问题：

```js
const { classes: { stu: { name } } } = school
console.log(name)  // 'Bob'
```

可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。

### 9）对 rest 参数的理解

扩展运算符被用在函数形参上时，**它还可以把一个分离的参数序列整合成一个数组**：

```js
function mutiple(...args) {
  let result = 1;
  for (var val of args) {
    result *= val;
  }
  return result;
}
mutiple(1, 2, 3, 4) // 24
```

这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：

```js
function mutiple(...args) {
  console.log(args)
}
mutiple(1, 2, 3, 4) // [1, 2, 3, 4]
```

这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点**经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。**

### 10）ES6 中模板语法与字符串处理

ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：

```js
var name = 'css'   
var career = 'coder' 
var hobby = ['coding', 'writing']
var finalString = 'my name is ' + name + ', I work as a ' + career + ', I love ' + hobby[0] + ' and ' + hobby[1]
```

仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：

```js
var name = 'css'   
var career = 'coder' 
var hobby = ['coding', 'writing']
var finalString = `my name is ${name}, I work as a ${career} I love ${hobby[0]} and ${hobby[1]}`
```

字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：

- 在模板字符串中，空格、缩进、换行都会被保留
- 模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算

基于第一点，可以在模板字符串里无障碍地直接写 html 代码：

```js
let list = `
	<ul>
		<li>列表项1</li>
		<li>列表项2</li>
	</ul>
`;
console.log(message); // 正确输出，不存在报错
```

基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：

```js
function add(a, b) {
  const finalString = `${a} + ${b} = ${a+b}`
  console.log(finalString)
}
add(1, 2) // 输出 '1 + 2 = 3'
```

除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：

- **存在性判定**：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf > -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。

  - - **includes**：判断字符串与子串的包含关系：

      ```js
      const son = 'haha' 
      const father = 'xixi haha hehe'
      father.includes(son) // true
      ```

    - **startsWith**：判断字符串是否以某个/某串字符开头：

      ```js
      const father = 'xixi haha hehe'
      father.startsWith('haha') // false
      father.startsWith('xixi') // true
      ```

    - **endsWith**：判断字符串是否以某个/某串字符结尾：

      ```js
      const father = 'xixi haha hehe'
        father.endsWith('hehe') // true
      ```

- **自动重复**：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：

## 3.JavaScript基础

### 1）new操作符的实现原理

**new操作符的执行过程**：

（1）首先创建了一个新的空对象

（2）设置原型，将对象的原型设置为函数的 prototype 对象

（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）

（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

具体实现：

```js
function objectFactory() {
    let newObject = null;
    let constructor = Array.prototype.shift.call(arguments);
    let result = null;
    // 判断参数是否是一个函数
    if (typeof constructor !== "function") {
        console.error("type error");
	    return;
    }
    // 新建一个空对象，对象的原型为构造函数的 prototype 对象
    newObject = Object.create(constructor.prototype);
    // 将 this 指向新建对象，并执行函数
    result = constructor.apply(newObject, arguments);
    // 判断返回对象
    let flag = result && (typeof result === "object" || typeof result === "function")
    //判断返回结果
    return flag ? result : newObject
}
// 使用方法
objectFactory(构造函数，初始化参数)
```

### 2）map 和 Object 的区别

|          |                             Map                              |                            Object                            |
| -------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 意外的键 |        Map默认情况下不包含任何键，只包含显式插入的键         | Object 有一个原型，原型链上的键名有可能和自己在对象上的设置的键名产生冲突 |
| 键的类型 |      Map的键可以使任意值，包含函数、对象或任意基本类型       |             Object的键必须是 String 或是 Symbol              |
| 键的顺序 | Map中的key是有序的。因此，当迭代的时候，Map 对象可以插入的顺序返回键值 |                      Object的键是无序的                      |
| 个数     |          Map的键值对个数可以轻易地通过size属性获取           |   Object的键值对个数只能手动计算(Object.keys(obj).length)    |
| 迭代     |           Map 是 iterable 的，所以可以直接被迭代。           |       迭代Object需要以某种方式获取它的键然后才能迭代。       |
| 性能     |              在频繁增删键值对的场景下表现更好。              |          在频繁添加和删除键值对的场景下未作出优化。          |

### 3）map和weakMap的区别

**（1）Map**

​	map 本质上就是键值对的集合，但是普通的 Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。

​	实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：

```js
const map = [
     ["name","张三"],
     ["age",18],
]
```

Map数据结构有以下操作方法：

- **size**：map.size 返回Map结构的成员总数。前提：map 是 Map 的实例，上述代码是数组则不能用size
- **set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）
- **get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined
- **has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中
- **delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false
- **clear()**：map.clear() 清除所有成员，没有返回值

Map结构原生提供是三个遍历器生成函数和一个遍历方法

- keys()：返回键名的遍历器。
- values()：返回键值的遍历器。
- entries()：返回所有成员的遍历器。
- forEach()：遍历Map的所有成员。

```js
const map = new Map([
    ["foo",1],
    ["bar",2],
])
for(let key of map.keys()){
    console.log(key) //foo  bar
}
for(let value of map.values()){
    console.log(value) //1 2
}
for(let items of map.entries()){
    console.log(items) // ["foo",1]  ["bar",2]
}
map.forEach((value,key,map) => {
    console.log(key,value); //foo 1  bar 2
})
```

**（1）WeakMap**

WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。**其键必须是对象**，原始数据类型不能作为key值，而值可以是任意的。这意味着如果没有其他对象引用这个键，它可能会被垃圾回收器回收，从而释放内存。

另外，WeakMap 的键不是枚举的，这意味着你不能像普通的 Map 一样遍历它的键。这是因为 WeakMap 的设计初衷是为了解决**内存泄漏问题**，而不是作为通用的键值存储。

ps：WeakMap 解决内存泄漏的主要方式是通过使用弱引用的键。在普通的 Map中，如果你使用对象作为键，并将这个对象存储在 Map 中，即使你不再需要这个对象，只要Map存在，这个对象就无法被垃圾回收器回收，从而可能导致内存泄漏。

​	但在 WeakMap 中，如果对象作为键，并且没有其他引用指向这个对象，即使这个对象作为键存在于 WeakMap 中，他也可能被垃圾回收器回收。这是因为 WeakMap 中的键是弱引用的，垃圾回收器不会考虑 WeakMap 的键来确定对象是否可以被回收。

因此，如果你在 WeakMap 中使用对象作为键，并且在其他地方没有对这个对象的引用，那么当这个对象被垃圾回收器回收时，与之关联的值也会被自动移除，从而避免了内存泄漏问题。

该对象也有以下几种方法：

- **set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）
- **get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。
- **has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。
- **delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。

其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。

**总结：**

- Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
- WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。

**弱引用**

​	弱引用是指对对象的引用，不会影响对象被垃圾回收器回收的过程。在许多编程语言中，对对象的引用会增加对象的引用计数，当引用计数为零时，对象会被垃圾回收器回收。但是，如果一个对象被弱引用所引用，即使没有其他强引用指向它，垃圾回收器也可以回收该对象，因为弱引用不会增加对象的引用计数。

在 JavaScript 中，WeakMap 和 WeakSet 使用了弱引用的概念。当对象作为 WeakMap 的键或 WeakSet 的成员时，如果这些对象没有其他引用指向它们，它们仍然可能被垃圾回收器回收，而不会因为存在于 WeakMap 或 WeakSet 中而阻止它们被回收。

### 4）JavaScript 有哪些内置对象

​	全局的对象（ global objects ）或称标准内置对象，不要和 "全局对象（global object）" 混淆。这里说的全局的对象是说在全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。

**标准内置对象的分类：**

（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、nul 字面量

（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt()等

（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如Object、Function、Boolean、Symbol、Error等

（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date

（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp

（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array

（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。

例如 Map、Set、WeakMap、WeakSet

（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。例如 SIMD 等

（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等

（10）控制抽象对象  例如 Promise、Generator 等

（11）反射  例如 Reflect、Proxy

（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等

（13）WebAssembly

（14）其他  例如 arguments

**总结：**

​	js中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。

### 5）常用的正则表达式有哪些

```js
// （1）匹配 16 进制颜色值
var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;

// （2）匹配日期，如 yyyy-mm-dd 格式
var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;

// （3）匹配 qq 号
var regex = /^[1-9][0-9]{4,10}$/g;

// （4）手机号码正则
var regex = /^1[34578]\d{9}$/g;

// （5）用户名正则
var regex = /^[a-zA-Z\$][a-zA-Z0-9_\$]{4,16}$/;
```

### 6）对JSON的理解

​	JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。

​	在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。

​	因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。

在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理

- JSON.stringify() 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数**将数据对象转化为 JSON 格式的字符串**。
- JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。

### 7）JavaScript脚步延迟加载的方法有哪些

延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。

一般有以下几种方式：

- **defer 属性**：给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。
- **async 属性**：给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。
- **动态创建 DOM 方式**：动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。
- **使用 setTimeout 延迟方法：**设置一个定时器来延迟加载js脚本文件
- **让 JS 最后加载：**将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。

### 8）JavaScript 类数组对象的定义,并如何转化为数组

​	一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。

常见的类数组转换为数组的方法有这样几种：

（1）通过 call 调用数组的 slice 方法来实现转换

```js
Array.prototype.slice.call(arrayLike);
```

（2）通过 call 调用数组的 splice 方法来实现转换

```javascript
Array.prototype.splice.call(arrayLike, 0);
```

（3）通过 apply 调用数组的 concat 方法来实现转换

```js
Array.prototype.concat.apply([], arrayLike);
```

（4）通过 Array.from 方法来实现转换

```js
Array.from(arrayLike);
```

### 9）数组有哪些原生方法

- 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。
- 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。
- 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。
- 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。
- 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。
- 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法
- 数组归并方法 reduce() 和 reduceRight() 方法

### 10）Unicode、UTF-8、UTF-16、UTF-32的区别？

- `Unicode` 是编码字符集（字符集），而`UTF-8`、`UTF-16`、`UTF-32`是字符集编码（编码规则）；
- `UTF-16` 使用变长码元序列的编码方式，相较于定长码元序列的`UTF-32`算法更复杂，甚至比同样是变长码元序列的`UTF-8`也更为复杂，因为其引入了独特的**代理对**这样的代理机制；
- `UTF-8`需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而`UTF-16`不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；
- 如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用`UTF-8`就比`UTF-16`节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么`UTF-16`就占优势了，可以节省很多空间；

### 11）常见的位运算符有哪些？其计算规则是什么？

​	现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。

常见的位运算有以下几种：

| 运算符 | 描述 | 运算规则                                                 |
| ------ | ---- | -------------------------------------------------------- |
| `&`    | 与   | 两个位都为1时，结果才为1                                 |
| `|`    | 或   | 两个位都为0时，结果才为0                                 |
| `^`    | 异或 | 两个位相同为0，相异为1                                   |
| `~`    | 取反 | 0变1，1变0                                               |
| `<<`   | 左移 | 各二进制位全部左移若干位，高位丢弃，低位补0              |
| `>>`   | 右移 | 各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃 |

只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用`if ((i & 1) == 0)`代替`if (i % 2 == 0)`来判断a是不是偶数。

### 12）为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?

`arguments`是一个对象，它的属性是从 0 开始依次递增的数字，还有`callee`和`length`等属性，与数组相似；但是它却没有数组常见的方法属性，如`forEach`, `reduce`等，所以叫它们类数组。

要遍历类数组，有三个方法：

（1）将数组的方法应用到类数组上，这时候就可以使用`call`和`apply`方法，如：

```js
function foo(){
    Array.prototype.forEach.call(arguments, a => console.log(a))
}
```

（2）使用Array.from方法将类数组转化成数组：‌

```js
function foo(){
    const arrArgs = Array.from(arguments)
    arrArgs.forEach(a => console.log(a))
}
```

3）使用展开运算符将类数组转化成数组

```js
function foo(){
    const arrArgs = [...arguments]
    arrArgs.forEach(a => console.log(a))
}
```

### 13）什么是 DOM 和 BOM？

- DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。
- BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。

### 14）浏览器的事件循环机制

任务队列：存放宏任务

微任务队列：存入微任务

执行栈：存储同步任务

1. JS是单线程，防止代码阻塞，我们把代码（任务）分为：同步和异步
2. 同步代码给js引擎执行，异步代码交给宿主环境
3. 同步代码放入执行栈中，异步代码等待时机成熟 (比如定时器完成后) 送入任务队列排队
4. 执行栈执行完毕，会去任务队列看是否有异步任务，有就送到执行栈执行，反复循环查看执行，这个过程是**事件循环(eventloop)**

​	JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

**总方针是先同步再异步，异步中先微任务，在宏任务。**

#### 重点：

​	**同步代码**：**立即**放入**js引擎**(js主程序)执行，并**原地等待**结果

​	**异步代码**：先放入**宿主环境**(浏览器/node)，不必原地等待结果，并**不阻塞**主线程继续往下执行，异步结果在**将来执行**

​	异步代码又分为 宏任务 和 微任务

​		宏任务由宿主(浏览器、Node)发起、微任务由js引擎发起

​		**Promise本身同步，then/catch的回调函数是异步的**

- 常见的同步代码：console.log(1)
- 常见的异步代码：setTimeout()、setInterval()、Ajax、Fetch、事件绑定
- 常见的微任务：Promise.then/catch、Async/await、queuMicrotask等。
- 常见宏任务：script（js整体代码）、ajax、setTimeout、setInterval、IO操作、UI交互、postMessage等。

故 事件循环可以理解为是一个桥梁，连接着应用程序的js和系统调用之间的通道。其过程为：

1. 执行一个宏任务（一般为一段script），若没有可选的宏任务，就直接处理微任务。
2. 执行中遇到微任务，就将其添加到微任务队列中。
3. 执行中遇到宏任务，就将其提交到宏任务队列中。
4. 执行完成当前执行的宏任务(<scritpt>标签就是一个宏任务)后，去查询当前有无需要执行的微任务，就有执行。
5. 检查渲染，若需要渲染，浏览器执行渲染任务。
6. 渲染完毕后，JS线程会去执行下一个宏任务。。。（如此循环）

```js
console.log("script start");
const promiseA = new Promise((resolve, reject) =>{
    console.log("init promiseA");
    resolve("promiseA")
})

const promiseB = new Promise((resolve,reject) =>{
    console.log("init promiseB");
    resolve("promiseB")
});
setTimeout(()=>{
    console.log("setTimeout run");
    promiseB.then(res =>{
       console.log("promiseB res :>> ", res);
    });
    console.log("setTimeout end");
},500)

promiseA.then(res =>{
   console.log("promiseA res :>> ", res);
})

queueMicrotask(()=> {
    console.log("queue Microtask run");
})
console.log("script end");

// script start
// init promiseA
// init promiseB
// script end
// promiseA res :>>  promiseA
// queue Microtask run
// setTimeout run
// setTimeout end
// promiseB res :>>  promiseB
```

### 15）escape、encodeURI、encodeURIComponent 的区别

- encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。
- encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。
- escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。

### 16）对AJAX的理解，实现一个AJAX请求

​	**定义**：AJAX是异步的JavaScript和XML。简单来说，就是**使用XMLHTTPRequest对象与服务器通信**。它可以使用JSON、XML、HTML和text文本格式发送和接收数据。AJAX最吸引人的就是它的"异步"特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。

​	概念：AJAX是浏览器与服务器进行**数据通信**的技术。

```js
// 创建 XMLHttpRequest 对象
    let xhr = new XMLHttpRequest();
    // 配置请求
    xhr.open('GET', 'https://jsonplaceholder.typicode.com/posts/1', true);
    // 定义响应处理函数
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300) {
            // 请求成功，处理响应数据
            console.log(xhr.responseText);
        } else {
            // 请求失败，处理错误信息
            console.error('请求失败: ' + xhr.status);
        }
    };
    // 定义错误处理函数
    xhr.onerror = function() {
        console.error('请求错误');
    };
    // 发送请求
    xhr.send();

//--------------------------------------------------------
let xhr = new XMLHttpRequest();
// 创建 Http 请求
xhr.open("GET", url, true);
// 设置状态监听函数
xhr.onreadystatechange = function() {
  if (this.readyState !== 4) return;
  // 当请求成功时
  if (this.status === 200) {
    handle(this.response);
  } else {
    console.error(this.statusText);
  }
};
// 设置请求失败时的监听函数
xhr.onerror = function() {
  console.error(this.statusText);
};
// 设置请求头信息
xhr.responseType = "json";
xhr.setRequestHeader("Accept", "application/json");
// 发送 Http 请求
xhr.send(null);
```

使用Promise封装AJAX

```js
// promise 封装实现：
function getJSON(url) {
  // 创建一个 promise 对象
  let promise = new Promise(function(resolve, reject) {
    let xhr = new XMLHttpRequest();
    // 新建一个 http 请求
    xhr.open("GET", url, true);
    // 设置状态的监听函数
    xhr.onreadystatechange = function() {
      if (this.readyState !== 4) return;
      // 当请求成功或失败时，改变 promise 的状态
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    // 设置错误监听函数
    xhr.onerror = function() {
      reject(new Error(this.statusText));
    };
    // 设置响应的数据类型
    xhr.responseType = "json";
    // 设置请求头信息
    xhr.setRequestHeader("Accept", "application/json");
    // 发送 http 请求
    xhr.send(null);
  });
  return promise;
}
```

### 17）JavaScript为什么要进行变量提升，它导致了什么问题？

变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。

​	造成变量声明提升的**本质原因**是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。

首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。

- **在解析阶段**，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。

- - 全局上下文：变量定义，函数声明
  - 函数上下文：变量定义，函数声明，this，arguments

- **在执行阶段**，就是按照代码的顺序依次执行。

那为什么会进行变量提升呢？主要有以下两个原因：

- 提高性能
- 容错性更好

**（1）提高性能**

在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。

在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。

**（2）容错性更好**

变量提升可以在一定程度上提高JS的容错性，看下面的代码：

```js
a = 1;
var a;
console.log(a);
```

如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。

虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。

**总结：**

- 解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间
- 声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行

变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：

```js
var tmp = new Date();
function fn(){
	console.log(tmp);
	if(false){
		var tmp = 'hello world';
	}
}
fn();  // undefined
```

在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。

可以将内部的var tmp = 'hello world'; 改为let tmp = 'hello world';解决此问题

### 18）什么是尾调用，使用尾调用有什么好处？

​	尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。

### 19）**ES6**模块与**CommonJS**模块有什么异同？

ES6 Module和CommonJS模块的区别： 

- CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；
- import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。 

ES6 Module和CommonJS模块的共同点： 

- CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。

### 20）常见的DOM操作有哪些

#### 1）DOM 节点的获取

DOM 节点的获取的API及使用：

```js
getElementById // 按照 id 查询
getElementsByTagName // 按照标签名查询
getElementsByClassName // 按照类名查询
querySelectorAll // 按照 css 选择器查询

// 按照 id 查询
var imooc = document.getElementById('imooc') // 查询到 id 为 imooc 的元素
// 按照标签名查询
var pList = document.getElementsByTagName('p')  // 查询到标签为 p 的集合
console.log(divList.length)
console.log(divList[0])
// 按照类名查询
var moocList = document.getElementsByClassName('mooc') // 查询到类名为 mooc 的集合
// 按照 css 选择器查询
var pList = document.querySelectorAll('.mooc') // 查询到类名为 mooc 的集合
```

#### 2）DOM 节点的创建

**创建一个新节点，并把它添加到指定节点的后面。**已知的 HTML 结构如下：

```html
<html>
  <head>
    <title>DEMO</title>
  </head>
  <body>
    <div id="container"> 
      <h1 id="title">我是标题</h1>
    </div>   
  </body>
</html>
```

要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：

```js
// 首先获取父节点
var container = document.getElementById('container')
// 创建新节点
var targetSpan = document.createElement('span')
// 设置 span 节点的内容
targetSpan.innerHTML = 'hello world'
// 把新创建的元素塞进父节点里去
container.appendChild(targetSpan)
```

#### 3）DOM 节点的删除

**删除指定的 DOM 节点，**已知的 HTML 结构如下：

```html
<html>
  <head>
    <title>DEMO</title>
  </head>
  <body>
    <div id="container"> 
      <h1 id="title">我是标题</h1>
    </div>   
  </body>
</html>
```

需要删除 id 为 title 的元素，做法是：

```js
// 获取目标元素的父元素
var container = document.getElementById('container')
// 获取目标元素
var targetNode = document.getElementById('title')
// 删除目标元素
container.removeChild(targetNode)
```

或者通过子节点数组来完成删除：

```js
// 获取目标元素的父元素
var container = document.getElementById('container')
// 获取目标元素
var targetNode = container.childNodes[1]
// 删除目标元素
container.removeChild(targetNode)
```

#### 4）修改 DOM 元素

修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。

**将指定的两个 DOM 元素交换位置，**已知的 HTML 结构如下：

```html
<html>
  <head>
    <title>DEMO</title>
  </head>
  <body>
    <div id="container"> 
      <h1 id="title">我是标题</h1>
      <p id="content">我是内容</p>
    </div>   
  </body>
</html>
```

现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：

```js
// 获取父元素
var container = document.getElementById('container')   
 
// 获取两个需要被交换的元素
var title = document.getElementById('title')
var content = document.getElementById('content')
// 交换两个元素，把 content 置于 title 前面
container.insertBefore(content, title)
```

### 21）use strict是什么意思 ? 使用它区别是什么？

use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：

- 消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;
- 消除代码运行的不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；
- 为未来新版本的 Javascript 做好铺垫。

区别：

- 禁止使用 with 语句。
- 禁止 this 关键字指向全局对象。
- 对象不能有重名的属性。

### 22）如何判断一个对象是否属于某个类？

1. 在 JavaScript 中，可以使用 `instanceof` 操作符来判断一个对象是否属于某个类（构造函数）。`instanceof` 操作符用于检测一个对象是否是某个类的实例，它的语法如下：

   ```js
   object instanceof constructor
   ```

   其中，`object` 是要检测的对象，`constructor` 是要检测的类（构造函数）。

   例如，假设有一个类 `Person`，可以这样判断一个对象是否属于 `Person` 类：

   ```js
   function Person(name,age) {
       this.name = name;
       this.age = age;
   }
   var person = new Person('John',28)
   console.log(person instanceof Person); // true
   ```

   需要注意的是，`instanceof` 操作符只能用于判断对象是否是某个类的实例，而不能用于判断对象是否继承自某个类。如果要判断对象是否继承自某个类，可以使用原型链上的 `isPrototypeOf()` 方法。

   ```js
   // 定义一个构造函数（类）
   function Person(name, age) {
       this.name = name;
       this.age = age;
   }
   
   // 创建一个对象
   var person = new Person('John', 30);
   
   // 使用 isPrototypeOf() 方法判断对象是否继承自某个类
   console.log(Person.prototype.isPrototypeOf(person)); // true
   
   ```

2. 通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数但是这种方式不是很安全，因为 constructor 属性可以被改写。

   ```js
   // 定义一个构造函数（类）
   function Person(name, age) {
       this.name = name;
       this.age = age;
   }
   
   // 创建一个对象
   var person = new Person('John', 30);
   
   // 使用 constructor 属性判断对象是否属于某个类
   console.log(person.constructor === Person); // true
   
   ```

3. 如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。

   ```js
   // 定义一个数组对象
   var arr = [1, 2, 3];
   
   // 使用 Object.prototype.toString.call() 方法来获取对象的内部 [[Class]] 属性
   var objClass = Object.prototype.toString.call(arr);
   
   // 输出 [[Class]] 属性
   console.log(objClass); // [object Array]
   
   // 判断对象是否是数组类型
   console.log(objClass === '[object Array]'); // true
   ```

   在这个示例中，`Object.prototype.toString.call(arr)` 返回了 `[object Array]`，表示 `arr` 对象是一个数组类型。通过比较返回的字符串是否为 `[object Array]`，我们可以确定对象是否属于某个特定的内置引用类型。

### 23）强类型语言和弱类型语言的区别

- **强类型语言**：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。
- **弱类型语言**：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串'12'和整数3进行连接得到字符串'123'，在相加的时候会进行强制类型转换。

两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。

### 24）解释性语言和编译型语言的区别

（1）解释型语言

使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下

- 解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；
- 只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；
- JavaScript、Python等属于解释型语言。

（2）编译型语言

使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：

- 一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；
- 与特定平台相关，一般无法移植到其他平台；
- C、C++等属于编译型语言。

**两者主要区别在于：**前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。

### 25）for...in和for...of的区别 

for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下

- for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；
- for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；
- 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；

**总结：**for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。

### 26）如何使用for...of遍历对象 

for…of是作为ES6新增的遍历方式，允许遍历一个含有 **iterator(可迭代)接口** 的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。

如果需要遍历的对象是类数组对象，用Array.from转成数组即可。

```js
var obj = {
    0:'one',
    1:'two',
    length:2
}
obj = Array.from(obj)
for(var k of obj){
    console.log(k) //one two
}
```

### 27）普通对象和可迭代对象

普通对象和可迭代对象之间的主要区别在于它们是否具有迭代功能。

#### 1.普通对象：

- 普通对象是 JavaScript 中最基本的对象类型之一，它们通过字面量或构造函数创建，可以包含零个或多个属性。
- 普通对象通常用于存储键值对，访问对象的属性可以使用点语法（例如 `obj.property`）或者方括号语法（例如 `obj['property']`）。
- 普通对象没有内置的迭代功能，因此不能直接使用 `for...of` 循环来迭代对象的属性或键值对。

#### 2.可迭代对象：

- 可迭代对象是指实现了迭代器接口的对象，它们具有内置的迭代功能，可以通过迭代器遍历对象的元素。
- 可迭代对象可以使用 `for...of` 循环进行迭代，也可以使用迭代器对象的 `next()` 方法手动迭代。
- 在 JavaScript 中，数组、字符串、Set、Map 等内置对象都是可迭代对象，它们都实现了迭代器接口，因此可以直接使用 `for...of` 循环来遍历它们的元素。

总之，普通对象和可迭代对象的区别在于是否具有内置的迭代功能。普通对象没有内置的迭代功能，因此不能直接使用 `for...of` 循环进行迭代，而可迭代对象具有内置的迭代功能，可以直接使用 `for...of` 循环进行迭代。

####    3.迭代器(iterator)接口和生成器(generator)函数的关系

任意一个对象实现了遵守迭代器协议的[Symbol.iterator]方法，那么该对象就可以调用[Symbol.iterator]返回一个遍历器对象。生成器函数就是遍历器生成函数，故可以把generator赋值给对象的[Symbol.iterator]属性，从而使该对象具有迭代器接口。

```js
class ClassRoom {
    constructor(address, name, students) {
        this.address = address;
        this.name = name;
        this.students = students;
    }
    entry(student) {
        this.students.push(student);
    }
    
    *[Symbol.iterator]() {
        yield* this.students;
    }
}
```

### 28）ajax、axios、fetch的区别

**（1）AJAX**

​	Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式[网页](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E7%BD%91%E9%A1%B5)应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：

- 本身是针对MVC编程，不符合前端MVVM的浪潮
- 基于原生XHR开发，XHR本身的架构不清晰
- 不符合关注分离（Separation of Concerns）的原则
- 配置和调用方式非常混乱，而且基于事件的异步模型不友好。

```js
var xhr = new XMLHttpRequest()
xhr.open('GET','http://xxxxx')
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200){
        console.log(xhr.responseText);
    }
}
xhr.send()
```

**（2）Fetch**

​	fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。**fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象**。

fetch的优点：

- 语法简洁，更加语义化
- 基于标准 Promise 实现，支持 async/await
- 更加底层，提供的API丰富（request, response）
- 脱离了XHR，是ES规范里新的实现方式

fetch的缺点：

- fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
- fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})
- fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
- fetch没有办法原生监测请求的进度，而XHR可以

```js
fetch('https://api.example.com/data')
    .then(function(response) {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(function(data) {
        console.log(data);
    })
    .catch(function(error) {
        console.error(error);
    });
```

**（3）Axios**

Axios 是一种基于Promise封装的HTTP客户端，其特点如下：

- 浏览器端发起XMLHttpRequests请求
- node端发起http请求
- 支持Promise API
- 监听请求和返回
- 对请求和返回进行转化
- 取消请求
- 自动转换json数据
- 客户端支持抵御XSRF攻击

```js
axios.get('https://api.example.com/data')
    .then(function(response) {
        console.log(response.data);
    })
    .catch(function(error) {
        console.error(error);
    });
```

### 29）数组的遍历方法有哪些

| 方法                    | 是否改变原数组 | 特点                                                         |
| :---------------------- | -------------- | ------------------------------------------------------------ |
| forEach()               | 否             | 数组方法，不改变原数组，没有返回值                           |
| map()                   | 否             | 数组方法，不改变原数组，有返回值，可链式调用                 |
| filter()                | 否             | 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用 |
| for...of                | 否             | for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环 |
| every()和some()         | 否             | 数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false. |
| find()和findIndex()     | 否             | 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值 |
| reduce()和reduceRight() | 否             | 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作 |

### 30）forEach和map方法有什么区别

1. **返回值：**
   - `forEach()` 方法不返回任何值（或者说返回值为 `undefined`），它只是对数组中的每个元素执行指定的函数，不会生成新的数组。
   - `map()` 方法返回一个新数组，新数组中的元素是原数组经过指定函数处理后的结果。原数组不受影响。
2. **返回值的用途：**
   - `forEach()` 方法主要用于对数组中的每个元素执行某种操作，例如打印每个元素的值、修改数组元素等。它没有返回值，因此不能对数组进行转换或映射。
   - `map()` 方法主要用于对数组中的每个元素进行某种转换或映射，生成一个新的数组。它的返回值是一个新数组，可以直接使用或存储下来。
3. **副作用：**
   - `forEach()` 方法允许在回调函数中对原数组进行修改，因为它不会返回新的数组，而是对原数组进行遍历操作。
   - `map()` 方法不会修改原数组，它会生成一个新的数组作为返回值，因此不会产生副作用。

举例来说，如果你想要对数组中的每个元素进行平方操作，你可以使用 `map()` 方法：

```js
var arr = [1, 2, 3];

var squaredArr = arr.map(function(item) {
    return item * item;
});

console.log(squaredArr); // [1, 4, 9]
```

而如果你只是想打印数组中的每个元素，你可以使用 `forEach()` 方法：

```js
var arr = [1, 2, 3];

arr.forEach(function(item) {
    console.log(item);
});
```

总的来说，`forEach()` 主要用于对数组进行遍历操作，而 `map()` 主要用于对数组进行转换或映射操作，生成一个新的数组。

### 31）addEventListener()方法的参数和使用

`addEventListener()` 方法用于向指定的元素添加事件监听器。它接受三个参数：

1. **事件类型（Event Type）：** 要监听的事件类型，例如 "click"、"mouseover" 等。
2. **事件处理函数（Event Listener）：** 当指定的事件类型被触发时要执行的函数。这个函数可以是已命名的函数，也可以是匿名函数。
3. **是否在捕获阶段捕获（Capture）：** 一个可选的布尔值参数，表示事件是在捕获阶段（true）还是冒泡阶段（false）进行处理。默认值为 false。

以下是一个简单的示例，演示了如何使用 `addEventListener()` 方法：

```html
html复制代码<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>addEventListener Example</title>
</head>
<body>

<button id="myButton">Click me</button>

<script>
// 获取按钮元素
var button = document.getElementById('myButton');

// 添加事件监听器
button.addEventListener('click', function(event) {
    alert('Button clicked!');
});
</script>

</body>
</html>
```

在这个示例中，我们获取了 id 为 "myButton" 的按钮元素，并使用 `addEventListener()` 方法向该按钮添加了一个 "click" 事件监听器。当按钮被点击时，会弹出一个对话框提示 "Button clicked!"。

## 4.原型与原型链

### 1）对原型、原型链的理解

#### 什么是原型？

在 JavaScript 中，**每个函数都有 prototype 属性**，称之为 **原型**。它指向一个对象，这个对象就是该函数的 **原型对象**。

- 原型可以放一些属性和方法，共享给实例对象使用
- 原型可以继承

所以，当我们说一个函数的原型，实际上指的是函数对象的 `prototype` 属性所指向的对象，**即原型对象。**

`__proto__`：只要是对象身上都有 `__proto__`属性

prototype 也是对象，当一个函数在原型上没找到属性或方法时它会继续往上找

Object 是最大的对象，Object的原型对象（Object.prototype）是 null。

举例说明：

函数可以有属性，每个函数都有一个特殊的属性叫做原型 prototype

```js
function doSomething(){}
console.log(doSomething.prototype)
```

控制台输出

```js
{
    constructor: ƒ doSomething(),
    __proto__: {
        constructor: ƒ Object(),
        hasOwnProperty: ƒ hasOwnProperty(),
        isPrototypeOf: ƒ isPrototypeOf(),
        propertyIsEnumerable: ƒ propertyIsEnumerable(),
        toLocaleString: ƒ toLocaleString(),
        toString: ƒ toString(),
        valueOf: ƒ valueOf()
    }
}
```

上面这个对象，就是大家常说的原型对象

#### 什么是原型链？

**对象**都有`__proto__`属性，这个属性指向它的原型对象，原型对象也是对象，也有`__proto__`属性，指向原型对象的原型对象，这样一层一层形成的 **链式结构称为原型链**，最顶层找不到则返回 null

![img](C:\Users\TW0069768\Desktop\gitHub\notes\面试总结\原型链图.png)

每个对象的 `__proto__`都是指向它的构造函数的原型对象 prototype 的

```
person.__proto__ === Person.prototype
```

构造函数是一个函数对象，是通过 Function 构造器产生的

```
Person.__proto__ === Function.prototype
```

原型对象本身是一个普通对象，而普通对象的构造函数都是 Object

```
Person.prototype.__proto__ === Object.prototype
```

刚刚上面说了，所有的构造器都是函数对象，函数对象都是 Function 构造产生的

```
Object.__proto__ === Function.prototype
```

Object 的原型对象也有 `__proto__` 属性指向 null，null是原型链的顶端

```
Object.prototype.__proto__ === null
```

总结：

- 一切对象都是继承自 Object 对象，Object 对象直接继承根源对象 null
- 一切的函数对象（包括 Object 对象），都是继承自 Function 对象
- Object 对象直接继承自 Function 对象
- Function 对象 的`__proto__`会指向自己的原型对象，最终还是继承自 Object 对象

使用class语法，用extends进行继承，或直接改变对象的`__proto__`指向。

```js
class Car {
    constructor(brand) {
        this.band = band;
    }
    showBrand() {
         console.log("the brand of car :>> ", this.brand);
    }
}

// js中使用关键字extends可以创建一个类，该类继承了另一个类的属性和方法。在下例子中，ElectricCar是一个类，它通过extends Car 继承了Car 类的属性和方法。这意味着ElectricCar类拥有了Car类的所有特性，并且可以在此基础上进行扩展和自定义。
class ElectricCar extends Car {
    constructor(brand, duration) {
        super(brand);
        this.duration = duration;
    }
    showDuratino() {
         console.log(`duration of this ${this.brand} ElectricCar :>> `, this.duration);
    }
}

ElectricCar.prototype.showOriginator = function (originator) {
    console.log(`originator of this ElectricCar :>> `, originator);
}

const tesla = new ElectricCar("tesla","600km");
tesla.showBrand(); // the brand of car :>>  tesla
tesla.showDuration(); // duration of this tesla ElectricCar :>>  600km
console.log("tesla instanceof Car :>> ", tesla instanceof Car); // tesla instanceof Car :>>  true
console.log("tesla instanceof ElectricCar :>> ", tesla instanceof ElectricCar); // tesla instanceof ElectricCar :>>  true
console.log("tesla.__proto__ :>> ", tesla.__proto__); // tesla.__proto__ :>>  Car {}
console.log("ElectricCar.prototype === tesla.__proto__  :>> ", ElectricCar.prototype === tesla.__proto__); // ElectricCar.prototype === tesla.__proto__  :>>  true
tesla.showOriginator("Mask"); // originator of this  ElectricCar :>>  Mask

const bydCar = {
  brand: "比亚迪",
  duration: "666km",
};
bydCar.__proto__ = ElectricCar.prototype;

bydCar.showBrand(); //the brand of car :>>  比亚迪
bydCar.showDuration(); // duration of this 比亚迪 ElectricCar :>>  666km
```

### 2）原型修改、重写

**修改原型**：

1. 直接修改原型对象：

   ```js
   function Person(name) {
       this.name = name;
   }
   
   Person.prototype.age = 25;
   
   // 修改原型
   Person.prototype.age = 30;
   ```

2. 使用 `Object.setPrototypeOf()`：

   ```js
   function Person(name) {
       this.name = name;
   }
   
   Person.prototype.age = 25;
   
   let john = new Person("John");
   
   // 修改原型
   Object.setPrototypeOf(john, { age: 30 });
   ```

**重写原型**：

1. 完全重写原型对象：

   ````js
   function Person(name) {
       this.name = name;
   }
   
   // 重写原型
   Person.prototype = {
       age: 30,
       greet: function() {
           return "Hello, my name is " + this.name + " and I am " + this.age + " years old.";
       }
   };
   ````

2. 使用构造函数的新实例来重写原型：

   ```js
   function Person(name) {
       this.name = name;
   }
   
   Person.prototype.age = 25;
   
   // 重写原型
   Person.prototype = new Person();
   Person.prototype.age = 30;
   ```

### 3）原型链指向

```js
p.__proto__  // Person.prototype
Person.prototype.__proto__  // Object.prototype
p.__proto__.__proto__ //Object.prototype
p.__proto__.constructor.prototype.__proto__ // Object.prototype
Person.prototype.constructor.prototype.__proto__ // Object.prototype
p1.__proto__.constructor // Person
Person.prototype.constructor  // Person
```

### 4）原型链终点是什么？如何打印出原型链的终点？

由于`Object`是构造函数，原型链终点是`Object.prototype.__proto__`，而`Object.prototype.__proto__=== null // true`，所以，原型链的终点是`null`。原型链上的所有原型都是对象，所有的对象最终都是由`Object`构造的，而`Object.prototype`的下一级是`Object.prototype.__proto__`。

### 5）如何获得对象非原型链上的属性？

使用后`hasOwnProperty()`方法来判断属性是否属于原型链的属性：

```js
function iterate(obj){
   var res=[];
   for(var key in obj){
        if(obj.hasOwnProperty(key))
           res.push(key+': '+obj[key]);
   }
   return res;
} 
```

## 5.执行上下文 / 作用域链 / 闭包

### 1）对闭包的理解

**闭包是指有权访问另一个函数作用域中变量的函数**，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

简单理解：**闭包 = 内存函数 + 引用的外层函数变量**

```js
function outer() {
    const a = 1;
    function inner() {
        console.log(a);
    }
    inner()
}
outer()
//闭包不一定要有return，但是当外部想要使用闭包的变量时，则此时需要 return
function outer() {
    let a = 10;
    return function inner() {
        console.log(a);
    }
}
const fn = outer();
fn();

//普通函数，统计函数调用次数
let i = 0;
function fn() {
    i++;
    console.log(`函数调用了${i}次`)
}
fn()//函数调用了1次
fn()//函数调用了2次
let i = 1000;
fn()//函数调用了1001次
// 因为i是全局变量所以会被篡改。

//使用闭包可以实现变量私有化
function count() {
    let i = 0;
    function fn(){
        i++;
        console.log(`函数调用了${i}次`)
    }
    return fn;
}
const fun = count();
fun()//函数调用了1次
fun()//函数调用了2次
let i = 1000;
fun()//函数调用了3次
// 使用闭包 让i变成私有变量，外面可以使用但不能修改
```

```js
function outer() {
    var num = 0; //共享的num 
    function inner() {
        num++;//内部函数中调用外部函数的变量num并执行++操作
        console.log(num);
    }
    return inner;//返回的inner 将同时保留了num所在的作用域(闭包)
}

var f1 = outer(); // f1 相当于inner + 共享的num，每次调用f1()  num都不会被销毁
f1();//1
f1();//2
var f2 = outer();
f2();//1
f2();//2

// 此处是一个闭包，闭包变量是num，内部函数inner可以访问外部函数outer中的num变量，每次调用外部函数时，都会开辟相应的内存空间，闭包变量num会保存在该内存空间中，直到该外部函数的内存空间被销毁。上述代码中调用外部函数outer时开辟了一个内存空间，变量num也保存在该内存空间中，因此两次调用f1() 结果为1,2;当f2()再此调用函数outer()时，又会重新开辟一个内存空间。所以两次调用f2() 结果也为1,2

function init() {
    var name = "JJLin";//name是一个被init创建的局部变量
    function displayName() {
        //displayName() 是内部函数，一个闭包
        console.log(name);//使用了父函数中声明的变量
    }
    displayName();
}
init();
//init()创建了一个局部变量name和一个名为 displayName() 的函数。
//displayName() 是定义在 init() 里的内部函数，并且仅在 init() 函数体内可用。
//请注意，displayName() 没有自己的局部变量。然而，因为它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。
```

闭包是作用域应用的特殊场景。js中常见的作用域包含全局作用域、函数作用域、块级作用域。要知道**js中自由变量的查找是函数定义的地方，向上级作用域查找，不是在执行的地方。**

#### 常见的闭包使用有两种场景：一种是函数作为参数被传递；一种是函数作为返回值被返回。

```js
// 函数作为返回值
function create() {
    let a = 100;
    return function() {
        console.log(a)
    }
}

const fn = create();
const a = 200;
fn();// 100
// 当执行fn()时，内部函数会尝试访问变量a。根据JavaScript的作用域链规则，内部函数会先在自己的作用域中查找变量a,如果找不到，则会继续向上级作用域查找。在此例子中，内部函数在自己的作用域中找不到变量a,但它成功地在外部函数create的作用域中找到了变量a，其值为100。因此，执行 fn() 后会输出 100。


// 函数作为参数被传递
function print(fb) {
    const b = 200;
    fb();
}
const b = 100;
function fb(){
    console.log(b)
}
print(fb);//100;
// 由于JavaScript中存在作用域链的概念，内部函数可以访问外部函数的变量。在这个例子中，fb函数在其作用域中找不到变量b，因此会继续向上一级作用域寻找，最终找到了全局作用域中的变量b,其值为100。因此，执行 print(fb) 后会输出 100。
```

```js
//假如，我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其他元素（例如header）的字号：

function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + 'px';
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);

document.getElementById('size-12').onclick = size12;
document.getElementById('size-14').onclick = size14;
document.getElementById('size-16').onclick = size16;
```

#### 闭包实现模块化和私有变量

使用闭包可以实现模块化，将一些相关的函数和变量封装在一个函数中，并返回一个公共接口。这样就可以防止这些函数和变量被其他代码意外修改，提高了代码的安全性和可维护性。
在 JavaScript 中，没有原生的私有变量机制，但是可以通过闭包实现。将一个变量定义在函数内部，然后在函数返回的闭包中使用这个变量，这个变量就成为了私有变量，只能被闭包内的函数访问。

```js
let counterModule = (function () {
    let count = 0;
    function increment() {
        count++;
        console.log('Count:', count);
    }

    function decrement() {
        count--;
        console.log('Count:', count);
    }

    return {
        increment,
        decrement
    };
})();

counterModule.increment(); // 输出：Count: 1
counterModule.increment(); // 输出：Count: 2
counterModule.decrement(); // 输出：Count: 1

counterModule = null; // 不使用闭包时，手动清除

//在上面的示例中，我们使用了立即执行函数（IIFE）来创建一个闭包，并且在闭包内部定义了两个函数 increment() 和 decrement()，用于对一个私有变量 count 进行增加和减少操作。然后我们返回一个包含这两个函数的对象，这样就可以通过该对象对外提供这些方法，从而实现模块化。

//通过使用闭包，count 变量被定义在 createCounter() 函数内部，外部代码无法直接访问它，从而实现了私有变量的效果。我们可以将 count 变量隐藏在闭包内部，防止外部代码对其进行修改。这样可以有效地避免命名冲突和数据污染等问题，同时也可以提高代码的可维护性和安全性。
```

#### 闭包的缺点

闭包的缺点主要有两个：

1. 内存泄漏：由于闭包中的函数引用了外部函数的变量，而外部函数的作用域在函数执行结束后并不会被销毁，这就导致了闭包函数中的变量也无法被销毁，从而占用了内存空间。如果闭包被滥用，可能会导致内存泄漏的问题。
2. 性能问题：闭包中的函数访问外部函数的变量需要通过作用域链来查找，而作用域链的长度决定了查找的速度。如果闭包层数较深，作用域链就会很长，从而影响了函数的执行效率。

#### 解决闭包的措施

1. 及时释放闭包：如果不再需要使用闭包，可以手动将其赋值为 null，从而释放闭包中占用的内存空间。
2. 减少闭包层数：尽量减少闭包层数，避免作用域链过长，从而提高函数的执行效率。
3. 使用立即执行函数：可以使用立即执行函数来避免闭包的内存泄漏问题。由于立即执行函数在执行结束后会被立即销毁，因此其中的变量也会被释放。
4. 使用模块化编程：可以使用模块化编程来避免闭包的性能问题。在模块化编程中，每个模块都是一个独立的作用域，不会对全局作用域造成影响，从而避免了作用域链过长的问题。

```js
function foo() {
    let count = 0;
    return function () {
        return ++count;
    }
}

let counter = foo();//创建闭包

console.log(counter());//1
console.log(counter());//2
console.log(counter());//3

counter = null; // 释放闭包
```

### 2）对作用域、作用域链的理解

##### 1）全局作用域和函数作用域

（1）全局作用域

- 最外层函数和最外层函数外面定义的变量拥有全局作用域
- 所有未定义直接赋值的变量自动声明为全局作用域
- 所有window对象的属性拥有全局作用域
- 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。

（2）函数作用域

- 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到
- 作用域是分层的，内层作用域可以访问外层作用域，反之不行

##### 2）块级作用域

- 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由`{ }`包裹的代码片段）
- let和const声明的变量不会有变量提升，也不可以重复声明
- 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。

**作用域链：**

​	在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

​	作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。**

​	作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。

### 3）对执行上下文的理解

##### 1. 执行上下文类型

**（1）全局执行上下文**

任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。

**（2）函数执行上下文**

当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。

**（3）**`eval`**函数执行上下文**

执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。

##### 2. 执行上下文栈

- JavaScript引擎使用执行上下文栈来管理执行上下文

- 当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。

  ```js
  let a = 'Hello World!';
  function first() {
    console.log('Inside first function');
    second();
    console.log('Again inside first function');
  }
  function second() {
    console.log('Inside second function');
  }
  first();
  //执行顺序
  //先执行second(),在执行first()
  ```

##### 3. 创建执行上下文

创建执行上下文有两个阶段：**创建阶段**和**执行阶段**

**1）创建阶段**

（1）this绑定

- 在全局执行上下文中，this指向全局对象（window对象）
- 在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined

（2）创建词法环境组件

- 词法环境是一种有**标识符——变量映射**的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。
- 词法环境的内部有两个组件：**加粗样式**：环境记录器:用来储存变量个函数声明的实际位置**外部环境的引用**：可以访问父级作用域

（3）创建变量环境组件

- 变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。

**2）执行阶段**

此阶段会完成对变量的分配，最后执行完代码。

**简单来说执行上下文就是指：**

在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。

在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。

- 全局上下文：变量定义，函数声明
- 函数上下文：变量定义，函数声明，`this`，`arguments`

## 6. this / call / apply /bind

#### 1. 对this对象的理解

this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。

- 第一种是**函数调用模式**，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
- 第二种是**方法调用模式**，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
- 第三种是**构造器调用模式**，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
- 第四种是 **apply 、 call 和 bind 调用模式**，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。

在JavaScript中，call()、apply()、bind()是用于改变函数执行上下文(即this指向)的方法。

**call()** 方法允许以指定的this值和单独给出的参数列表来调用函数，语法 `funcion.call(thisArg,arg1,arg2,...)` ，第一个参数表示this要指向的对象，其余参数表示调用函数需要传入的参数，返回调用函数的返回结果，属于立即执行函数；

你可以用一个对象来替换当前对象，然后在新对象的环境中调用函数

```js
function sayHello() {
    console.log('Hello ' + this.name);
}

let person = {name:'JJLin'};
sayHello.call(person) //HelloJJLin
```

call()应用

```js
function Person(name) {
    this.name = name;
    this.say = function () {
        console.log("我是" + this.name);
    }
}

function Student(studentNo,name) {
    this.studentNo = studentNo;
    // 此this指向Student
    // 通过改变this指向，使Person里的this指向Student
    // 从而实现使用Student就拥有Person里的name属性以及say方法，即实现继承
    // 具体来说，下述代码会执行Person函数，并将当前Student函数中的this指向传递给Person函数，同时还会传入name参数。这样一来Person函数中使用this.name = name的赋值操作，实际上会将name属性添加到Student实例对象上，从而实现了对Person中属性的继承。
    // 这种继承方式称为借用构造函数，它允许一个构造函数在另一个构造函数内部被调用，并将当前对象作为新构造函数的 this。
    Person.call(this,name)
}

// 实例化Student
let student1 = new Student("20240104","小白");
student1.say();//我是小白
console.log("姓名："+student1.name+",学号："+student1.studentNo);//姓名：小白,学号：20240104
```

**apply()** 方法与call()类似，区别在于它接收两个参数，第二个参数是一个参数数组而不是一些列参数，语法 `function.apply(thisArg, [argsArr])`，第一个参数表示this要指向的对象，第二个参数表示调用函数需要传入的参数所组成的数组，返回调用函数的返回结果，属于立即执行函数；

```js
function intr(greeting,farewell) {
    console.log(greeting + ',' + this.name);//Hello,JJLin
    console.log(farewell + ',' + this.name);//Goodbye,JJLin
}
let person = {name:'JJLin'}

intr.apply(person,['Hello', 'Goodbye'])
```

```js
// 此处若用let声明，则第一个调用函数输出undefined
// 此处let声明的变量虽然也是全局变量但其不会成为全局对象window的属性，因为ES6 标准中，let 声明的变量不会被添加到全局对象上，从而避免了全局变量的污染和不可预测的行为。故say()直接调用时为undefined

var word = '我是window';
function say(params1,params2) {
    console.log(params1+" " + params2 +"," + this.word);
}

let obj = {
    word: "我是obj"
}
let newObj = {
    word:"我是newObj"
}

say("Hi","friend")//Hi friend,我是window  //let 声明 则输出：Hi friend,undefined
say.call(obj,"Hi","friend")//Hi friend,我是obj    this指向obj
say.apply(newObj,["Hi","friend"]) //Hi friend,我是newObj   this指向newObj
```

**bind()** 接收一个及其以上的参数，和call()一致，但bind方法创建一个新的函数，当被调用时，将其this值设为提供的值，然后再调用原函数。bind() 不会立即执行，而是返回一个新的函数,而不是调用新函数的返回结果。

```js
let person = {name:'JJLin'};
function sayHi() {
    console.log('Hi ' + this.name);
}
let sayHiAgain = sayHi.bind(person);
sayHiAgain()//Hi JJLin
```

```js
var obj = {};
function test() {
    console.log(this === obj);
}
test()// false

var testObj = test.bind(obj);
testObj()//true
```

```js
var word = "我是window";
function say(params1, params2) {
    console.log(params1 + " " + params2 + "，" + this.word)
}
let Obj1 = {
    word: "我是newObj1"
}
let Obj2 = {
    word: "我是newObj2"
}
//返回一个新的函数
let newFunc = say.bind(Obj1, "hello", "friend");
newFunc()   //hello friend，我是newObj1

//可将其改为立即执行函数，此时返回和call()，apply（）相同
say.bind(Obj2, "hello", "friend")();   //hello friend，我是newObj2
```

区别：

- 当我们使用一个函数需要改变this指向时才会用到 call、apply、bind
- 如果传递的参数不多，则使用 `fn.call(obj,arg1,arg2,...)`
- 如果传递的参数很多，则可以使用数组整理好参数，调用 `fn.apply(obj,[arg1,arg2,...])`
- 如果想生成一个新对象长期绑定某个函数供某个对象使用，则使用const newFn = fn.bind(this.obj) newFn(arg1,arg2,...)

## 7.异步编程

### 1）异步编程的实现方式？

JavaScript中的异步机制可以分为以下几种：

- **回调函数** 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。
- **Promise** 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。
- **generator** 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。
- **async 函数** 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。

### 2）setTimeout、Promise、Async/Await 的区别

#### （1）setTimeout

```js
console.log('script start')	//1. 打印 script start
setTimeout(function(){
    console.log('settimeout')	// 4. 打印 settimeout
})	// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数
console.log('script end')	//3. 打印 script start
// 输出顺序：script start->script end->settimeout
```

#### （2）Promise

Promise本身是**同步的立即执行函数**， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。

```js
console.log('script start')
let promise1 = new Promise(function (resolve) {
    console.log('promise1')
    resolve()
    console.log('promise1 end')
}).then(function () {
    console.log('promise2')
})
setTimeout(function(){
    console.log('settimeout')
})
console.log('script end')
// 输出顺序: script start->promise1->promise1 end->script end->promise2->settimeout
```

当JS主线程执行到Promise对象时：

- promise1.then() 的回调就是一个 task
- promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue
- promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中
- setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况

#### （3）async/await

```js
async function async1(){
   console.log('async1 start');
    await async2();
    console.log('async1 end')
}
async function async2(){
    console.log('async2')
}
console.log('script start');
async1();
console.log('script end')
// 输出顺序：script start->async1 start->async2->script end->async1 end
```

async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。

await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。

### 3）对 Promise 的理解

Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。	

Promise可以被翻译成承诺、保证，promise有3种状态 成功（fulfiled）或者失败（rejected），还有一个等待状态（pending）。

**Promise的特点：**

- 对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，`pending`（进行中）、`fulfilled`（已成功）、`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“**承诺**”；
- 一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从`pending`变为`fulfilled`，从`pending`变为`rejected`。这时就称为`resolved`（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。

**Promise的缺点：**

- 无法取消Promise，一旦新建它就会立即执行，无法中途取消。
- 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
- 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

**总结：**

Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。

状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。

### 4）Promise的基本用法

#### （1）创建Promise对象

Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。

```JS
const promise = new Promise(function(resolve, reject) {
  // ... some code
  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
```

**一般情况下都会使用**`new Promise()`**来创建promise对象，但是也可以使用**`promise.resolve`**和** `promise.reject`**这两个方法：**

- **Promise.resolve**

`Promise.resolve(value)`的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：

```js
Promise.resolve(11).then(function(value){
  console.log(value); // 打印出11
});
```

`resolve(11)`代码中，会让promise对象进入确定(`resolve`状态)，并将参数`11`传递给后面的`then`所指定的`onFulfilled` 函数；

创建promise对象可以使用`new Promise`的形式创建对象，也可以使用`Promise.resolve(value)`的形式创建promise对象；

- **Promise.reject**

`Promise.reject` 也是`new Promise`的快捷形式，也创建一个promise对象。代码如下：

```js
Promise.reject(new Error(“我错了，请原谅俺！！”));
```

就是下面的代码new Promise的简单形式：

```js
new Promise(function(resolve,reject){
   reject(new Error("我错了，请原谅俺！！"));
});
```

下面是使用resolve方法和reject方法：

```js
function testPromise(ready) {
  return new Promise(function(resolve,reject){
    if(ready) {
      resolve("hello world");
    }else {
      reject("No thanks");
    }
  });
};
// 方法调用
testPromise(true).then(function(msg){
  console.log(msg);
},function(error){
  console.log(error);
});
```

上面的代码的含义是给`testPromise`方法传递一个参数，返回一个promise对象，如果为`true`的话，那么调用promise对象中的`resolve()`方法，并且把其中的参数传递给后面的`then`第一个函数内，因此打印出 “`hello world`”, 如果为`false`的话，会调用promise对象中的`reject()`方法，则会进入`then`的第二个函数内，会打印`No thanks`；

#### （2）Promise方法

Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。

1. ##### then()

   Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。

   then方法接收 **两个函数**作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。

   两个函数只会有一个被调用。promise的执行 结果只能是成功（fulfiled）或者失败（rejected）

   函数的返回值将被用作创建then返回的Promise对象。

   ```js
   let promise = new Promise((resolve, reject) => {
       setTimeout(() => {
           resolve(2000)
       }, 1000)
       console.log(11111);
   })
   
   promise.then(res => {
       console.log(res); //打印2000
       return res + 1000;//这个函数的返回值，返回的就是这个promise对象捕捉到的成功的值
   }).then(res => {
       console.log(res);//打印3000，上一个promise对象return的值
   })
   /*
   打印顺序
   11111
   2000
   3000
   */
   ```

   刚才我们看到了then接受两个参数，一个是成功的回调、一个是失败的回调，看起来好像也不是那么优雅，promise里除了then还提供了catch方法：

2. ##### catch捕捉操作

   catch就是专门捕捉错误的回调函数。

   ```js
   let promise = new Promise((resolve, reject) => {
       setTimeout(() => {
           reject(2000)//失败以后这个reject会把失败的结果捕捉到
       }, 1000)
       console.log(11111);
   })
   
   promise.catch(res => {
       console.log(res);//catch里面就能拿到捕捉到的失败结果
   })
   /*
   打印结果：
   11111
   2000 (一秒以后)
   */
   ```

3. ##### finally

   该方法用于指定不管Promise对象最后状态如何，都会执行的操作。

   ```js
   // 服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。
   server.listen(port)
     .then(function () {
       // ...
     }).finally(server.stop);
   ```

   finally 方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是`fulfilled`还是`rejected`。这表明，`finally`方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。

   ```js
   promise
   .finally(() => {
     // 语句
   });
   
   // 等同于
   promise
   .then(
     result => {
       // 语句
       return result;
     },
     error => {
       // 语句
       throw error;
     }
   );
   // finally本质是then的特例，上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。
   ```

4. ##### all

   `Promise.all()`方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。

   现在我们有这么一个需求，一共有三个接口A、B、C，必须三个接口都成功以后，才能发起第四个请求，怎么实现呢？

   ```js
   //链式调用
   let getInfoA = new Promise((resolve, reject) => {
         console.log('小A开始执行了');
         resolve()
       }).then(res => {
         let getInfoB = new Promise((resolve, reject) => {
           console.log('小B开始执行了');
           resolve()
         }).then(res => {
           let getInfoC = new Promise((resolve, reject) => {
             console.log('小C开始执行了');
             resolve()
           }).then(res => {
             console.log("全部执行完了");
           })
         })
       })
   ```

   链式调用一层一层，很不优雅，

   ```js
   // all
   let getInfoA = new Promise((resolve, reject) => {
       console.log('小A开始执行了')
       resolve()
   })
   let getInfoB = new Promise((resolve, reject) => {
       console.log('小B开始执行了')
       resolve()
   })
   let getInfoC = new Promise((resolve, reject) => {
       console.log('小C开始执行了')
       resolve()
   })
   Promise.all([getInfoA, getInfoB, getInfoC]).then(res=>{
       console.log('全部执行完了！');
   })
   ```

   接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。非常完美，非常优雅。

5. ##### race

   `Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。

   ```js
   const p = Promise.race([p1, p2, p3]);
   ```

   上面代码中，只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给`p`的回调函数。

   现在又有一个需求，同样是接口A、B、C，只要有一个响应了，我就可以调接口D，那么怎么实现呢？

   ```js
   //传统方法实现
   1、传统方式
   let getInfoA = new Promise((resolve, reject) => {
       console.log('小A开始执行了')
       setTimeout((err => {
           resolve('小A最快')
       }),1000)
   }).then(res =>{
       console.log(res)
   })
   let getInfoB = new Promise((resolve, reject) => {
       console.log('小B开始执行了')
       setTimeout((err => {
           resolve('小B最快')
       }),1001)
   }).then(res =>{
       console.log(res)
   })
   let getInfoC = new Promise((resolve, reject) => {
       console.log('小C开始执行了')
       setTimeout((err => {
           resolve('小C最快')
       }),1002)
   }).then(res =>{
       console.log(res)
   })
   /*
   打印结果
   
   小A开始执行了
   小B开始执行了
   小C开始执行了
   小A最快
   */
   ```

   这个方法得写三遍，好像也不是那么优雅，一起来看下race应该怎么写？

   ```js
   2、race
   
   let getInfoA = new Promise((resolve, reject) => {
       console.log('小A开始执行了')
       setTimeout((err => {
           resolve('小A最快')
       }),1000)
   })
   let getInfoB = new Promise((resolve, reject) => {
       console.log('小B开始执行了')
       setTimeout((err => {
           resolve('小B最快')
       }),1001)
   })
   let getInfoC = new Promise((resolve, reject) => {
       console.log('小C开始执行了')
       setTimeout((err => {
           resolve('小C最快')
       }),1002)
   })
   Promise.race([getInfoA, getInfoB, getInfoC]).then(res => {
       console.log(res)
   })
   /*
   打印结果
   
   小A开始执行了
   小B开始执行了
   小C开始执行了
   小A最快
   */
   ```

   与Promise.all 相似的是，Promise.race都是以一个Promise对象组成的数组作为参数，不同的是，只要当数组中的其中一个Promsie状态变成resolved或者rejected时，就可以调用.then方法了。

### 5）Promise解决了什么问题

在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：

```js
let fs = require('fs')
fs.readFile('./a.txt','utf8',function(err,data){
  fs.readFile(data,'utf8',function(err,data){
    fs.readFile(data,'utf8',function(err,data){
      console.log(data)
    })
  })
})
```

上面的代码有如下缺点：

- 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。
- 如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。

`Promise`出现之后，代码变成这样：

```js
let fs = require('fs')
function read(url){
  return new Promise((resolve,reject)=>{
    fs.readFile(url,'utf8',function(error,data){
      error && reject(error)
      resolve(data)
    })
  })
}
read('./a.txt').then(data=>{
  return read(data) 
}).then(data=>{
  return read(data)  
}).then(data=>{
  console.log(data)
})
```

这样代码看起了就简洁了很多，解决了地狱回调的问题。

### 6）Promise.all 和Promise.race的区别和使用场景

**（1）Promise.all**

`Promise.all`可以将多个`Promise`实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是**一个结果数组**，而失败的时候则返回**最先被reject失败状态的值**。

Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。

需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。

**（2）Promise.race**

顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：

```js
Promise.race([promise1,timeOutPromise(5000)]).then(res=>{})
```

### 7）对 async/await 的理解

​	async/await其实是`Generator` 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么： 

```js
async function testAsy(){
   return 'hello world';
}
let result = testAsy(); 
console.log(result);
/*
Promise {<fulfilled>: 'hello world'}
[[Prototype]]: Promise
[[PromiseState]]: "fulfilled"
[[PromiseResult]]: "hello world"
*/
```

所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 `return` 一个直接量，async 会把这个直接量通过 `Promise.resolve()` 封装成 Promise 对象。

async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：`then()` 链来处理这个 Promise 对象，就像这样：

```js
async function testAsy(){
   return 'hello world'
}
let result = testAsy() 
console.log(result)
result.then(v=>{
    console.log(v)   // hello world
})
```

那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 `Promise.resolve(undefined)`。

联想一下 Promise 的特点——无等待，所以在没有 `await` 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。

**注意：**`Promise.resolve(x)` 可以看作是 `new Promise(resolve => resolve(x))` 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。

### 8）await 到底在等啥？

`await` 关键字在 `async/await` 中的作用是等待一个 Promise 对象的解析或拒绝。具体来说，`await` 等待的是一个异步操作的完成，这个异步操作通常是一个返回 Promise 对象的函数调用或一个 Promise 对象本身。

​	因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：

```js
function getSomething() {
    return "something";
}
async function testAsync() {
    return Promise.resolve("hello async");
}
async function test() {
    const v1 = await getSomething();
    const v2 = await testAsync();
    console.log(v1, v2);
}
test();
```

await 表达式的运算结果取决于它等的是什么。

- 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。
- 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。

```js
function testAsy(x){
   return new Promise(resolve=>{setTimeout(() => {
       resolve(x);
     }, 3000)
    }
   )
}
async function testAwt(){    
  let result =  await testAsy('hello world');
  console.log(result);    // 3秒钟之后出现hello world
  console.log('cuger')   // 3秒钟之后出现cuger
}
testAwt();
console.log('cug')  //立即输出cug
```

这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以'cug''最先输出，hello world'和‘cuger’是3秒钟后同时出现的。

### 9）async/await 的优势

单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。

假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 `setTimeout` 来模拟异步操作：

```js
/**
 * 传入参数 n，表示这个函数执行的时间（毫秒）
 * 执行的结果是 n + 200，这个值将用于下一步骤
 */
function takeLongTime(n) {
    return new Promise(resolve => {
        setTimeout(() => resolve(n + 200), n);
    });
}
function step1(n) {
    console.log(`step1 with ${n}`);
    return takeLongTime(n);
}
function step2(n) {
    console.log(`step2 with ${n}`);
    return takeLongTime(n);
}
function step3(n) {
    console.log(`step3 with ${n}`);
    return takeLongTime(n);
}
```

现在用 Promise 方式来实现这三个步骤的处理：

```js
function doIt() {
    console.time("doIt");
    const time1 = 300;
    step1(time1)
        .then(time2 => step2(time2))
        .then(time3 => step3(time3))
        .then(result => {
            console.log(`result is ${result}`);
            console.timeEnd("doIt");
        });
}
doIt();
// c:\var\test>node --harmony_async_await .
// step1 with 300
// step2 with 500
// step3 with 700
// result is 900
// doIt: 1507.251ms
```

输出结果 `result` 是 `step3()` 的参数 `700 + 200` = `900`。`doIt()` 顺序执行了三个步骤，一共用了 `300 + 500 + 700 = 1500` 毫秒，和 `console.time()/console.timeEnd()` 计算的结果一致。

如果用 async/await 来实现呢，会是这样：

```js
async function doIt() {
    console.time("doIt");
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time2);
    const result = await step3(time3);
    console.log(`result is ${result}`);
    console.timeEnd("doIt");
}
doIt();
```

结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样

### 10）async/await 对比Promise的优势

- 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担 
- Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅 
- 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余 
- 调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。 

### 11）async/await 如何捕获异常

```js
async function fn(){
    try{
        let a = await Promise.reject('error')
    }catch(error){
        console.log(error)
    }
}
```

## 8. 面向对象

### 1）对象创建的方式有哪些？

1. **字面量表示法**：最常见的方式是使用对象字面量表示法，通过花括号 `{}` 创建对象，并在花括号内部定义属性和方法。例如：

   ```js
   var person = {
       name:'jj',
       age:30,
       greet:function(){
           console.log('hello')
       }
   }
   ```

2. **构造函数**：可以使用构造函数创建对象。构造函数是一个普通的函数，使用 `new` 关键字调用，以创建新对象的实例。例如：

   ```js
   function Person(name,age) {
       this.name = name;
       this.age = age;
       this.greet = function(){
           console.log('hello')
       }
   }
   var person = new Person('jaychou',43)
   ```

3. **Object.create() 方法**：通过 `Object.create()` 方法创建对象，该方法可以指定对象的原型。例如：

   ```js
   var personPrototype = {
       greet: function() {
           console.log('hello')
       }
   }
   var person = Object.create(personPrototype)
   person.name = 'JJLin';
   person.age = 30;
   ```

4. **工厂函数**：可以使用工厂函数来创建对象，工厂函数是一个返回新对象的函数。例如：

   ```js
   function createPerson(name,age) {
       return {
           name:name,
           age:age,
           greet: function() {
           	console.log('hello')
       	}
       }
   }
   var person = createPerson('Jhon',30)
   ```

5. **类（ES6+）**：使用 ES6 中的类语法创建对象，类是一种特殊的函数，通过 `class` 关键字定义。例如：

   ```js
   class Person {
       constructor(name,age) {
           this.name = name;
           this.age = age;
       }
       greet() {
           console.log('hello!')
       }
   }
   var person = new Person('John',33)
   ```

### 2）对象继承的方式有哪些

**1.原型链继承**：

- 在原型链继承中，一个对象可以通过将另一个对象作为其原型来继承其属性和方法。
- 可以使用构造函数定义对象，然后通过设置 `prototype` 属性来指定其原型对象。
- 缺点是如果原型链过长或者在原型链中的对象属性被修改，可能会影响所有继承自该原型的对象。

```js
function Parent() {
    this.name = 'Parent'
}
Parent.prototype.sayHello = function() {
    console.log('Hello from' + this.name)
}
function Child() {
    this.name = 'Child';
}
Child.ptototype = new Parent()
var child = new Child()
child.sayHello(); // Hello from Child
```

**2.构造函数继承**：

- 在构造函数继承中，一个对象可以通过在另一个构造函数内调用 `call` 或 `apply` 来继承其属性。
- 这种方式避免了原型链继承中子类共享父类属性的问题，但是无法继承原型上的方法。

下列中，无法继承原型上的方法

```js
function Parent() {
    this.name = 'Parent'
}
Parent.prototype.sayHello = function() {
    console.log('Hello from' + this.name)
}
function Child() {
    //Child 构造函数首先通过 Parent.call(this) 调用了父类 Parent 的构造函数，将父类的属性继承给子类。这一步是构造函数继承。
    Parent.call(this);
    //设置子类特有的属性。
    this.name = 'Child';
}
var child = new Child()
child.sayHello(); //child.sayHello is not a function
```

下列中继承了父类中的方法

```js
function Parent(name) {
    this.name = name;
    this.sayHello = function() {
        console.log('Hello, my name is ' + this.name);
    };
}

function Child(name, age) {
    // 调用父类构造函数以继承父类的属性
    Parent.call(this, name);
    this.age = age;
}

var child = new Child('Alice', 10);
console.log(child.name); // Output: Alice
console.log(child.age); // Output: 10
child.sayHello(); // Output: Hello, my name is Alice
```

**3.组合继承**：

- 组合继承结合了原型链继承和构造函数继承的优点。
- 在组合继承中，首先通过构造函数继承属性，然后通过原型链继承方法。
- 这种方式克服了原型链继承和构造函数继承的一些缺点，是一种常用的继承方式。

```js
//定义父类 Parent：
function Parent() {
    this.name = 'Parent';
}
//该方法可以在任何继承 Parent 的子类中使用。
Parent.prototype.sayHello = function() {
    console.log('Hello from' + this.name)
}
//定义子类 Child：
function Child() {
    //Child 构造函数首先通过 Parent.call(this) 调用了父类 Parent 的构造函数，将父类的属性继承给子类。这一步是构造函数继承。
    Parent.call(this);// 使用构造函数继承父类的属性
    this.name = 'Child'; //设置子类特有的属性。
}
//将父类的一个实例作为子类的原型，这样子类就继承了父类原型上的方法。这一步是原型链继承。
Child.prototype = new Parent();// 原型链继承父类的方法
//由于 Child.prototype 现在指向了一个 Parent 的实例，所以需要重新设置 Child.prototype.constructor 为 Child，以确保 constructor 指向正确的构造函数。
Child.prototype.constructor = Child;//修复 constructor 指向

var child = new Child();
child.sayHello(); //Hello from Child
```

**4.原型式继承**：

- 原型式继承是一种简化的继承方式，可以通过浅复制一个对象来创建一个新对象。
- 使用 `Object.create()` 方法可以创建一个对象，并指定其原型对象。

```js
var parent = {
    name: 'Parent',
    sayHello: function() {
        console.log('Hello from ' + this.name);
    }
};
//child 对象通过 Object.create(parent) 创建，这个方法会创建一个新对象，并将 parent 对象作为新对象的原型。这样，child 对象就继承了 parent 对象的属性和方法。
var child = Object.create(parent);
//child 对象可以像普通对象一样添加自己的属性。在示例中，通过 child.name = 'Child' 将 name 属性重新赋值为 'Child'，覆盖了从 parent 对象继承的 name 属性。
child.name = 'Child';
child.sayHello(); // Output: Hello from Child
```

**5.寄生式继承**：

- 寄生式继承是在原型式继承的基础上增强对象，通常会在一个函数内部创建对象，添加属性和方法，然后返回该对象。

```js
//createChild 函数接收一个参数 parent，即要继承的父对象。
function createChild(parent) {
    //在函数内部，通过 Object.create(parent) 创建了一个新对象 child，该对象的原型为 parent，因此继承了 parent 对象的属性和方法。
    var child = Object.create(parent);
    //然后，添加了一个子对象特定的属性 name，并赋值为 'Child'。
    child.name = 'Child';
    return child;
}

var parent = {
    name: 'Parent',
    sayHello: function() {
        console.log('Hello from ' + this.name);
    }
};
//调用 createChild(parent) 函数创建了一个子对象 child，该子对象通过寄生式继承继承了 parent 对象的属性和方法，并添加了自己特定的属性 name。
var child = createChild(parent);
child.sayHello(); // Output: Hello from Child
```

**6.寄生组合式继承**：

- 寄生组合式继承是对组合继承的一种改进，通过不调用父类构造函数来避免两次调用父类构造函数。

```js
function Parent() {
    this.name = 'Parent';
}
//通过 Parent.prototype.sayHello 添加了一个 sayHello 方法，该方法可以在任何继承 Parent 的子类中使用。
Parent.prototype.sayHello = function() {
    console.log('Hello from ' + this.name);
};

function Child() {
    //Child 构造函数首先通过 Parent.call(this) 调用了父类 Parent 的构造函数，将父类的属性继承给子类。这一步是构造函数继承。
    Parent.call(this);
    //设置了子类特有的属性。
    this.name = 'Child';
}

// 寄生组合式继承关键在于这一行
//进行原型链继承，将父类原型的一个副本赋值给子类原型。
//这意味着 Child.prototype 对象的 constructor 属性将指向 Parent 构造函数，而不是我们期望的 Child 构造函数。
Child.prototype = Object.create(Parent.prototype);
//将子类原型的 constructor 属性指向 Child 构造函数，以修复构造函数指向。
Child.prototype.constructor = Child;

var child = new Child();
child.sayHello(); // Output: Hello from Child
```

## 9. 垃圾回收与内存泄漏

### 1）浏览器的垃圾回收机制

#### （1）垃圾回收的概念

**垃圾回收**：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。

**回收机制**：

- JavaScript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。
- JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续到页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在队和栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占的空间就会被释放。
- 不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。

#### （2）垃圾回收的方式

浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。

1）**标记清除**

- 标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为它们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
- 垃圾收集器在运行的时候会给存储在内存中的 所以变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清理工作，销毁那些带标记的值，并回收它们所占用的内存空间。

2）**引用计数**

- 另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。
- 这种方法会引起**循环引用**的问题：例如：` obj1`和`obj2`通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，`obj1`和`obj2`还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。

```js
function fun() {
    let obj1 = {};
    let obj2 = {};
    obj1.a = obj2; // obj1 引用 obj2
    obj2.a = obj1; // obj2 引用 obj1
}
```

这种情况下，就要手动释放变量占用的内存：

```js
obj1.a =  null
 obj2.a =  null
```

#### （3）减少垃圾回收

虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。

- **对数组进行优化**：在清空一个数组时，最简单的方法就是给其赋值为[ ],但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。
- **对 object 进行优化**：对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。
- **对函数进行优化**：在循环中的函数表达式，如果可以复用，尽量放在函数的外面。

### 2）哪些情况会导致内存泄漏

以下四种情况会造成内存的泄漏：

- **意外的全局变量：**由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
- **被遗忘的计时器或回调函数：**设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
- **脱离 DOM 的引用：**获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。
- **闭包：**不合理的使用闭包，从而导致某些变量一直被留在内存当中。

## 10.其他

### 1）Generator函数

​	阮一峰老师文档上的解释：Generator函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。

​	这个函数自己执行不了，得让别人帮忙执行，踢一脚（next()），走一步。

**基本用法**

```js
function* doSomething() {
    yield '吃饭'
    return '睡觉'
}
let newDoSomething = doSomething()//自己执行不了，需要指向一个状态机

console.log(newDoSomething.next()) // {value: "吃饭", done: false}
console.log(newDoSomething.next()) // {value: "睡觉", done: true}
```

**从上面的例子可以看出来，Generator 函数有四个特点：**

1、function后面有个小*，这个地方有两种写法，没啥太大区别；

```text
function* doSomething(){}
function *doSomething(){}
```

2、函数里面会有一个yield，把函数截成不同的状态；

```text
一个yield可以截成两个状态，也就需要两个next()触发；
```

3、Generator函数自己不会执行，而是会返回一个遍历器对象；

4、遍历器对象会通过.next()方法依次调用各个状态。

##### async、await项目中的使用

现在有一个封装好的，获取数据的方法，我们分别用promise、Generator、async来实现发请求，做一下比较：

```js
function getList() {
    return new Promise((resolve, reject) =>{
        $axios('/pt/getList').then(res => {
            resolve(res)
        }, err => {
            reject(err)
        })
    })
}
```

##### Promise

```js
function initTable() {
    getList().then(res => {
        console.log(res)
    }).catch(err => {
        this.$message(err) // element的语法
    })
}
/*
然后直接调用就可以
这么做看起来非常的简洁，但是如果多个请求调用
就会是.then,.then看起来非常不舒服
*/
```

##### Generator函数

```js
function *initTable(args) {
    const getList = yield getlist(args)
    return getList
}

function getList() {
    const g = initTable(this.searchParams)
    const gg = g.next().value
    gg.then(res =>{
        this.total = res.data.count
        if (res.data.list) {
          this.tableList = res.data.list
          this.tableList.forEach(e => {
            e.receiveAmt = format(e.receiveAmt)
          })
        } else {
          this.tableList = []
        }
    })
}

//这个看起来就比较伤，写起来非常麻烦
```

##### async await

```js
async initTable() {
    const getData = await getList(this.searchParams)
    return getData
},
getList(){
    this.initTable().then(res=>{
        this.tableList = res.data.list
    })
}
/*
这样写好像也很简单，而且非常方便
主要是如果调用多个接口，可以直接多个await
*/
```

### 2）浏览器渲染页面的过程

首先输入一个网址，浏览器会向服务器发起DNS请求，得到对应的IP地址（会被缓存一段时间，后续访问就不用再去向服务器查询）。之后会进行tcp三次握手与服务器建立连接，连接建立后，浏览器会代表用户发送一个初始的get请求，通常是请求一个html文件。服务器收到对应请求后，会根据相关的响应头和html内容进行回复。

一旦浏览器拿到了数据，就会开始解析信息，这个过程中，浏览器会根据html文件去构建DOM树，当遇到一些阻塞资源时（如同步加载的script标签）会去加载阻塞资源而停止当前DOM树构建（所以能够异步的或延迟加载的就尽量异步或延迟，同时页面的脚步还是越少越好）。在构建DOM树时，浏览器的主线程被占据着，不过浏览器的预加载扫描器会去请求高优先级的资源（如css、js、字体），预加载扫描器很好的优化了阻塞问题。接下来浏览器会处理css生成的css DOM树，将css规则转换为可以理解和使用的样式映射，这个过程非常快（通常小于一次DNS查询所需时间）。有了DOM树和CSS DOM树，浏览器会将其组合生成一个Render树，计算样式或渲染树会从DOM的根节点开始构建，遍历每一个可见节点（将相关样式匹配到每一个可见节点，并根据CSS级联去的每个节点的计算样式）。接下来开始布局，该过程（依旧是从根节点开始）会确定所有节点的宽高和位置，最后通过渲染器将其在页面上绘制。绘制完成了，并不代表交互也生效了，因为主线程可能还无法抽出时间去处理滚动、触摸等交互，要等到js加载完成，同时主线程空闲了整个页面才是正常可用的状态。

### 3）性能优化

#### 什么情况下会重绘和回流，常见的改善方案

浏览器请求到对应页面资源的时候，会将html解析成DOM，把css解析成css dom，然后将dom和css DOM合并就产生了Render Tree。在有了渲染树之后，浏览器会根据流式布局模型来计算它们在页面上的大小和位置，最后将节点绘制在页面上。

那么当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变，浏览器就会重新渲染页面，这个就是**浏览器的回流**。常见的回流操作有：页面的首次渲染、浏览器窗口尺寸改变、部分元素尺寸或位置变化、添加或删除可见的DOM、激活伪类、查询某些属性或调用方法（各种宽高的获取，滚动方法的执行等）

当页面中的元素样式改变不影响它在文档流的位置时（如color、background-color等），浏览器对应元素的样式，这个就是**重绘**。

可见：**回流必将导致重绘，重绘不一定会引起回流。回流比重绘的代价更高。**

#### 常见的改善方案：防抖、节流

- 在进行频繁操作时，使用防抖和节流来控制调用频率。（防抖和节流都是用来控制某个函数在一定时间内的触发次数.）

- 避免频繁操作DOM，可以利用DocumentFragment，来进行对应的DOM操作，将最后的结果添加到文档中。

- 灵活使用display：none属性，操作结束后将其显示出来，因为在display的属性为none的元素上进行的DOM操作不会引发回流和重绘

- 获取各种会引起重绘/回流的属性，尽量将其缓存起来，不要频繁的去获取。

- 对复杂动画采用决定定位，使其脱离文档流，否则它会频繁的引起父元素及其后续元素的回流。

#### 一次请求大量数据怎么优化，数据多导致渲染慢怎么优化

大量数据，应该采用异步的方式来接收，对数据进行一个分片处理，可以拆分成一个个的小单元数据，通过自定义的属性进行关联。这样数据分片完成。接下来渲染，由于大量数据，如果是长列表的话，这里就可以使用虚拟列表（当前页面需要渲染的数据拿到进行渲染，然后对前面一段范围以及后面一段范围，监听对应的滚动数据来切换需要渲染的数据，这样始终要渲染的就是三部分）。当然还有别的渲染情况，比如echarts图标大量点位数据优化等。

1. 分页加载：将数据分成多个较小的块进行加载，而不是一次性加载所有数据。通过分页加载，可以减少单次请求的数据量，从而减轻服务器和客户端的负担，提高渲染速度。
2. 延迟加载：只在需要时加载数据，而不是在初始加载时一次性加载所有数据。例如，在滚动到页面底部时才加载下一页的数据，或者在用户点击"加载更多"按钮时才进行数据加载。这样可以避免一次性加载大量数据，提高页面的响应速度。
3. 数据压缩和缓存：对传输的数据进行压缩，以减小数据的大小，从而减少网络传输时间。另外，使用适当的缓存机制，如浏览器缓存或缓存服务器，可以减少对服务器的请求次数，提高数据获取的速度。
4. 后端优化：在服务器端进行性能优化，如使用合适的数据库索引、优化查询语句、增加服务器资源等，以加快数据的检索和传输速度。
5. 前端优化：在前端代码中使用合适的技术和工具来优化数据的渲染速度。例如，使用虚拟滚动（Virtual Scrolling）或无限滚动（Infinite Scrolling）来优化大量数据的展示，只渲染可见区域的数据，而不是全部数据。
6. 数据预处理：如果可能的话，在服务器端对数据进行处理和过滤，以减少传输到前端的数据量。只传输前端需要的数据，可以减少不必要的网络传输和前端渲染的工作量。
7. 异步加载：使用异步加载技术，如AJAX或Fetch API，在后台获取数据的同时，不阻塞页面的加载和渲染。这样可以提高用户体验，让用户能够更快地与页面进行交互。

### 4） 防抖和节流

|              | 防抖（debounce）                                             | 节流（throttle）                                             |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 含义         | 单位时间内，频繁触发事件，只执行最后一次                     | 单位时间内，频繁触发事件，只执行一次                                                                      ------------------------------------------------------------- |
| 举例         | 设定1000毫秒定时器，当触发事件了，它会在1000毫秒之后执行，但是在还剩500毫秒的时候又触发了事件，那就会重新开始1000毫秒后执行。 | 设定1000毫秒执行，如果在1000毫秒内触发多次，也只在1000毫秒后执行一次。 |
| 代码实现思路 | 利用定时器，每次触发先清掉以前的定时器(**从新开始**)         | 利用定时器，等定时器执行完毕，才开启定时器(**不要打断**)     |
| 应用场景     | 英雄回城；搜索框搜索输入；登录、短信验证等按钮避免用户点击太快，发行多次请求；文本编辑器实时保存等。 | 英雄技能冷却；快速点击；鼠标滑动；监听滚动事件；下拉加载。等 |

```js
//防抖 - 单位时间内，频繁触发事件，只执行最后一次，英雄联盟回城
//<button>点击</button>
<script>
    var timer = null;
    function debounce() {
        // 首次执行timer是null,后续执行都需要先清除一下定时器，从新开始
        if (timer !== null) {
            clearTimeout(timer)
        }
        // 执行一次之后timer会变成1，后续++
        timer = setTimeout(() => {
            console.log('防抖');
        }, 1000)
    }
</script>
```

```js
// 节流 - 单位时间内，频繁触发事件，只执行一次，英雄联盟技能冷却
//<button>点击</button>
<script>
    var timer = null;
    function throttle() {
        if (timer !== null) {//如果timer还未置空，说明时间没到 return掉
            return
        }
        timer = setTimeout(() => {//打印节流，并2s后timer置空
            console.log('节流');
            timer = null;
        }, 2000);
    }
    var btn = document.querySelector('button');
    btn.addEventListener('click', () => {
        throttle()
    })
</script>
```

### 5） 浅拷贝和深拷贝

#### 浅拷贝

​	含义：把数组/对象中**第一层**的值，复制到新的数组/对象中的过程

​	使用场景：修改数组/对象，会影响另一个数组/对象时，想砍断它们的联系时使用

​	如何实现：for / for...in / 扩展运算符

```js
let a = 100;
let b = a;
a = 50;
console.log(b);//100
/*
   分析过程：定义了一个变量a，并赋值为100，
            声明一个变量b，把a里面的值赋予了a，则a=100;
            给a再次赋值50，此时a变为50；
            b未发生改变还是100
*/ 

let arr = ["小黑","小白"];
let brr = arr;
arr.push("小王");
console.log(brr);//['小黑', '小白', '小王']
/*
   分析过程：
        定义了一个变量arr，并赋值数组为 ["小黑","小白"]，当新定义一个数组/对象时，它首先会到堆内存中申请一块内存空间，每一块内存空间都有一个内存地址(0x00)，在内存空间里面会保存数组,所以arr里面装的就是内存地址，此内存地址指向堆内存中内存空间的真正数据

        声明一个变量brr，把arr里面的值赋予了arr，则brr里面装了和arr一样的内存地址(0x00);也指向堆内存中内存空间的真正数据

        当给arr指向的堆内存中添加一个新数据"小王"时，因为arr和brr指向同一个地址，所以brr也会变成['小黑', '小白', '小王']
*/ 

// let obj = {

//     name:'小李',
//     age:18
// }
// let obj2 = obj;
// obj.name = '小刘';
// console.log(obj2.name);//小刘
// 分析过程与数组分析过程一致，都是指向同一个内存地址

//1.for in 浅拷贝
let obj = {
    name:'小李',
    age:18
}
let obj2 = {};
for (const key in obj) {
    obj2[key] = obj[key]
}
obj.name = '小刘';
console.log(obj2.name);//小李
/*
只要新建一个数组对象就在堆内存中申请一块新的地址
  分析过程：
     声明了一个变量obj，则在堆内存中申请一个空间保存obj对象，并把内存地址(0x00)赋值给了obj，obj指向 0x00

     声明了一个obj2，则在堆内存中申请另一个空间保存obj2的空对象，并把内存地址(0x01)赋值给了obj2，obj2指向0x01

     使用for in 将obj里面的属性和值都复制给obj2里面

     修改了obj里面的name为'小刘'，因为obj和obj2指向不同，则obj2里面的name不会受影响
*/ 

//2.扩展运算符... 浅拷贝
let obj3 = {
    name:'小米',
    age:24
}

let obj4 = {...obj3}
console.log(obj4);//{name: '小米', age: 24}

// 3.Object.assign合并
let obj5 = {
    name:'小菜',
    age:27
}

let obj6 = Object.assign({},obj5);
console.log(obj6);//{name: '小菜', age: 27}
```

**浅拷贝的问题**：只能拷贝第一层的值，第二层的值还是相互引用

​	注意：只要看到一个新的对象或数组，都会在堆内存中开辟一个新的空间

```js
let arr = ["小刘","小明",["小花"]];
let brr = [...arr];
console.log(brr);//["小刘","小明",["小花"]]
arr[2].push("小黑")
console.log(brr);//["小刘","小明",["小花","小黑"]]

/*
 分析过程：
    arr里面是一个二维数组，每遇到一个[]都要开辟一个新的内存地址
    
    let arr = ["小刘","小明",["小花"]];相当于在堆内存中开辟了一个内存地址，0x001,存放着["小刘","小明",0x002],0x002存放着["小花"]，arr里面一层数组里面只放着小花的内存地址，真正的值在新的内存地址0x002放着

    所以拷贝出来的brr里面小花也是放着0x002的内存地址，arr和brr里面的都指向同一个内存地址，所以当arr[2].push("小黑")时，brr里面的值也会发生变化
*/ 
```

#### 深拷贝

​	含义：把数组/对象中**所有层**的值，复制到新的数组/对象中的过程

​	如何实现：创建新数组/对象，判断是基础数据类型则直接赋值，是对象类型(包括数组)则递归调用函数，继续创建判断

```js
let obj = {
    name: '小明',
    age: 18,
    grade: [100, 80],
    family: {
        fName: "王"
    }
}
// 深拷贝obj里面的所有值
let newObj = {}

function deepClone(newObj, obj) {
    for (const key in obj) {//key是：name、age、grade、family
        let value = obj[key];//obj[key] 就是obj的每一项的value 即：小明、18、[100,80]、{fName:"王"}
        if (value instanceof Array) {//如果拿到的值是数组
            newObj[key] = [];//{name:"小明",age：18,grade:[]}
            deepClone(newObj[key], value)
        } else if (value instanceof Object) {//如果拿到的值是对象
            newObj[key] = {};//{name:"小明",age：18,grade:[],family:{}}
            deepClone(newObj[key], value)
        }else{//拿到的数据就是基本数据类型，直接复制就可
            newObj[key] = value;
        }
    }
}

/*
分析过程：
  deepClone()方法用于克隆obj里面的所有数据给newObj这个空对象，
  首先循环obj，key即是obj的属性名，obj[key]即为obj的属性值,
  拿到obj中的每一项的值用value接住,
  然后判断value是否为数组/对象，引用数据类型还需要递归拷贝一次，当value拿到obj中的数组时，newObj[key] = [];意思为新数组newObj里面也添加一个名为grade的空数组即{name:"小明",age：18,grade:[]}，然后拿newObj[key] = []空数组 和 obj里面的数据[100, 80]继续递归，将[100, 80]复制到newObj的grade中即完成了对数组的拷贝
  对象拷贝和数组同理，只不过换成对象而已
*/ 
```

####  手写深拷贝

```js
function deepCopy(obj) {
    if (typeof obj !== 'object' || obj === null) {
        // 如果传人的参数不是对象或 是null，则直接返回该参数
        return obj;
    }
    
    // 根据obj的类型创建一个新的空对象或数组，必须先数组后对象，因为对象是数组的父集
    // Array.isArray() 判断是否为数组
    const newObj = Array.isArray(obj) ? [] : {};
    
    // 遍历obj的属性
    for (let key in obj) {
        // 递归调用deepCopy函数，对每个属性进行深拷贝
        newObj[key] = deepCopy(obj[key]);
    }
    
    return newObj;
}
```

使用该函数进行深拷贝时，它会递归遍历对象的所有属性，并创建一个完全独立的副本。这样可以确保修改副本的属性不会影响原始对象。

示例：

```js
const obj = {
    name : 'JJLin',
    age:42,
    address :{
        city: 'LA',
        country:'USA'
    }
}

const copy = deepCopy(obj);
console.log(copy);
// 输出: { name: 'John', age: 30, address: { city: 'LA', country: 'USA' } }

//修改副本的属性
copy.name = 'JAYChou';
copy.address.city = 'New York';

console.log(copy);
// 输出: { name: 'JAYChou', age: 42, address: { city: 'New York', country: 'USA' } }

console.log(obj);
// 输出: { name: 'JJLin', age: 42, address: { city: 'LA', country: 'USA' } }
```

### 6）手写快速排序

```js
function quickSort(arr) {
    if(arr.length <= 1){
        return arr
    }
    
    const pivotIndex = Math.floor(arr.length / 2);
    const pivot = arr[pivotIndex];
    const left = [];
    const right = [];
    
    for (let i = 0; i < arr.length; i++) {
        if (i === pivotIndex) {
            continue;
        }
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return [...quickSort(left), pivot, ...quickSort(right)];
}
//这是递归实现快速排序算法。它选择数组中间的元素作为基准值（pivot），然后将数组分为两部分：小于基准值的元素放在左边，大于基准值的元素放在右边。然后，对左右两个部分分别进行递归排序，最后将结果合并起来。
```

示例

```js
const arr = [5,2,9,1,7,6,3];
const sortedArr = quickSort(arr);
console.log(sortedArr);  // 输出: [1, 2, 3, 5, 6, 7, 9]
```

这只是一个简单的快速排序算法示例，可能并不适用于所有情况。在实际应用中，可能需要考虑性能优化、处理重复元素等问题。同时，还要注意快速排序的时间复杂度为O(n log n)，在处理大规模数据时可能需要考虑性能问题。

### 7）输入为两个一维数组，将这两个数组合并，去重，不要求排序，返回一维数组

```js
function mergeAndDeduplicateArrays(arr1,arr2) {
    const mergedArray = arr1.concat(arr2);
    const deduplicatedArray = [...new Set(mergedArray)];
    return deduplicatedArray;
}
```

这个函数将两个数组`arr1`和`arr2`合并成一个新的数组`mergedArray`，然后使用ES6的Set数据结构对新数组进行去重操作，得到去重后的数组`deduplicatedArray`。最后，将去重后的数组作为结果返回。

你可以调用这个函数来合并和去重两个数组，例如：

```js
const arr1 = [1, 2, 3];
const arr2 = [2, 3, 4, 5];
const mergedAndDeduplicatedArray = mergeAndDeduplicateArrays(arr1, arr2);
console.log(mergedAndDeduplicatedArray);  // 输出: [1, 2, 3, 4, 5]
```

### 8）Object.key和Object.values用法

**`Object.keys()`** 静态方法返回一个由给定对象自身的可枚举的字符串键 **属性名** 组成的数组。

**`Object.values()`** 静态方法返回一个给定对象的自有可枚举字符串键 **属性值 **组成的数组。

```js
const object = {
  a: 'somestring',
  b: 42,
  c: false,
};
console.log(Object.keys(object));//['a', 'b', 'c']

console.log(Object.values(object));//['somestring', 42, false]
```

### 9）JavaScript中遍历数组和对象的方法

数组：

1. for循环

   最基本的循环遍历函数

   ```js
   const items = ["item1", "item2", "item3"];
   const copyItems = [];
   for (let i = 0; i < items.length; i++) {
       copyItems.push(items[i]);
   }
   console.log(copyItems);//['item1', 'item2', 'item3']
   ```

2. for...of

   适用于遍历可迭代对象，例如数组、字符串、Map、Set等

   利用 for...of 可以 **遍历集合中的值 **而不是索引。

   ```js
   const items = ["item1", "item2", "item3"];       
   for (const e of items) {
       console.log(e); //item1  item2  item3
   }
   ```

3. forEach()

   数组的方法，用于对数组中每个元素执行指定操作。适用于需要对数组的每个元素进行操作。

   如果数组遍历的目的是为了得到返回值，那么使用`map()`方法，否则使用`forEach()`

   ```js
   const items = ["item1", "item2", "item3"];
   const copyItems = [];
   items.forEach(e => {
       copyItems.push(e);
   });
   console.log(copyItems);//['item1', 'item2', 'item3']
   ```

4. map()

   类似forEach，不同之处是map会 **返回一个新数组**，该数组的元素是对原数组每个元素调用回调函数后的返回值。

   ```js
   let arr = [1, 2, 3, 4];
   let newArr = arr.map((e) => e * 2);// 对数组中的每个元素乘以2
   console.log(newArr);//[2, 4, 6, 8]
   ```

   map() 方法接受一个函数作为参数。该函数调用时，map() 方法向他传入三个参数：当前成员、当前位置和数组本身。

   ```js
   [1, 2, 3].map(function(elem, index, arr) {
     return elem * index;
   });
   // [0, 2, 6]
   ```

5. filter()

   用于筛选数组中所有符合指定条件的 **所有元素**，并返回一个由这些元素组成的新数组，没找到返回空数组

   ```js
    let arr = [1, 2, 3, 4];
    let newArr = arr.filter((e) => e > 2)
    console.log(newArr);// [3, 4]
   ```

6. find()

   用于查找数组中符合指定条件的 **第一个元素**，并返回改元素的值，如果没有找到则返回undefined

   ```js
   let arr = [1, 2, 3, 4];
   let newArr = arr.find((e) => e > 2)
   console.log(newArr);// 3
   ```

7. every()

   用于检查数组中**所有元素**是否都符合指定条件，如果是返回true，否则返回false。如果数组为空，则返回true。

   ```js
   const arr = [2, 4, 6, 8, 10];
   const result = arr.every(e => e % 2 === 0);
   console.log(result); // 输出: true
   ```

8. some()

   用于检查数组中是否**至少有一个元素**符合指定条件，如果是则返回 true，否则返回 false。如果数组为空，则返回 false。

   ```js
   const arr = [1, 3, 5, 7, 10];
   const result = arr.some(e => e > 5);
   console.log(result); // 输出: true
   ```

9. reduce()

   用于将数组中的元素进行累积操作，最终返回一个值，它接受一个回调函数作为参数，且可以指定一个初始值。

   ```js
   array.reduce(function(accumulator, currentValue, currentIndex, array) {
     // ... 执行累积操作的逻辑 ...
   }, initialAccumulatorValue);
   /*
   1.function(accumulator, currentValue, currentIndex, array): 这是一个回调函数，用于指定累积操作。
   	参数 accumulator 代表累积的结果，
   	     currentValue 代表当前处理的元素，
   	     currentIndex 表示当前处理元素的索引，
   	     array 表示当前被处理的数组。
   2.initialAccumulatorValue: 可选参数，用于指定初始的累积值。如果指定了初始值，累积操作会从初始值开始；如果没指定，则累积操作会从数组的第一个元素开始。
   */
   const arr = [1, 2, 3, 4, 5, 6];
   const sum = arr.reduce((pre, current) => pre + current, 0);
   console.log(sum);//21
   ```

10. for...in

    for...in 不仅可以遍历对象也可以遍历数组，因为数组也只是一种特殊对象。

    ```js
    var a = [1,2,3]
    for(var i in a){
        console.log(a[i])//1 2 3
    }
    ```

    但是，`for...in`不仅会遍历数组所有的数字键，还会遍历非数字键。所以，**不推荐 **使用`for...in` **遍历数组**。

    ```js
    var a = [1, 2, 3]
    a.foo = true
    for (var i in a) {
        console.log(a[i])//1 2 3 true
    }
    ```

对象：

1. for...in

   用于遍历对象的可枚举属性。

   适用于遍历对象的属性，对于数组，`for...in`也会遍历数组的原型链上的属性，所以通常不建议用于遍历数组。

   ```js
   let obj = {
       a: 1,
       b: 2,
       c: 3
   };
   for (let key in obj) {
       console.log(key, obj[key]); // a 1  b 2  c 3
   }
   ```

2. Object.keys()

   返回一个包含对象的所有可枚举属性的**键**的数组。

   ```js
   const obj = { a: 1, b: 2, c: 3 };
   const keys = Object.keys(obj);
   console.log(keys); // 输出: ['a', 'b', 'c']
   ```

3. Object.values()

    返回一个包含对象的所有**值**的数组。

   ```js
   const obj = { a: 1, b: 2, c: 3 };
   const values = Object.values(obj);
   console.log(values); // 输出: [1, 2, 3]
   ```

4. Object.entries()

   返回一个包含对象的所有可枚举属性的键值对数组。

   ```js
   const obj = { a: 1, b: 2, c: 3 };
   const entries = Object.entries(obj);
   console.log(entries); // 输出: [['a', 1], ['b', 2], ['c', 3]]
   ```

### 10）JavaScript中检查变量类型的方法

1. `typeof` 运算符

   `typeof` 用于检查变量的数据类型，返回一个表示数据类型的字符串。

   ```js
   typeof "hello";  // 返回 "string"
   typeof 42;       // 返回 "number"
   typeof true;     // 返回 "boolean"
   ```

2. `instanceof` 运算符

   `instanceof` 运算符用于判断一个对象是否是一个类的实例。它通过检查对象的原型链来确定对象是否属于特定的类。通常用于判断自定义对象的类型。

   ```js
   function Person(name) {
       this.name =  name
   }
   let p1 = new Person('JJLin')
   console.log(p1 instanceof Person);//true
   ```

3. `Array.isArray`

   `Array.isArray`方法可以确定一个变量是否为数组类型。该方法在确定一个变量是否为数组时非常有用。

   ```js
   Array.isArray([]);    // 返回 true
   Array.isArray({});    // 返回 false
   ```

4. `Object.prototype.toString.call`

   使用 `Object.prototype.toString.call` 方法可以确定一个变量的类型，返回一个字符串，表示对象的类型。

   ```js
   Object.prototype.toString.call("hello"); // 返回 "[object String]"
   Object.prototype.toString.call(42);      // 返回 "[object Number]"
   ```

### 11）Object的方法

#### Object 的静态方法

`Object.keys`方法和`Object.getOwnPropertyNames`方法都用来遍历对象的属性。

- `Object.keys()`方法的参数的一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名

  ```js
  var obj = {
    p1: 123,
    p2: 456
  };
  
  Object.keys(obj) // ["p1", "p2"]
  ```

- `Object.getOwnPropertyNames()`方法与`Object.keys` 类似，也是接收一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。

  ```js
  var obj = {
    p1: 123,
    p2: 456
  };
  
  Object.getOwnPropertyNames(obj) // ["p1", "p2"]
  ```

  一般情况下，几乎总是使用`Object.keys`方法，遍历对象的属性。

#### Object 的实例方法

​	除了静态方法，还有不少方法定义在`Object.prototype`对象。它们称为实例方法，所有`Object`的实例对象都继承了这些方法。

`Object`实例对象的方法，主要有以下六个。

- `Object.prototype.valueOf()`：返回当前对象对应的值。

  `valueof` 方法的作用是返回一个对象的"值"，默认情况下返回对象本身

  ```js
  let obj = {
      a:1,
      b:2
  }
  console.log(obj.valueOf()===obj);//true
  ```

  上述代码中`obj.valueOf()`与`obj`本身，两者是一样的。

  ```js
  var obj = new Object()
  console.log(1+obj);// 1[object Object]
  ```

  上面代码将对象`obj`与数字`1`相加，这时 JavaScript 就会默认调用`valueOf()`方法，求出`obj`的值再与`1`相加。所以，如果自定义`valueOf`方法，就可以得到想要的结果。

  ```js
  var obj = new Object()
  obj.valueOf = function () {
  return 2
  }
  console.log(1+obj); //3
  ```

  上面代码自定义了`obj`对象的`valueOf`方法，于是`1 + obj`就得到了`3`。这种方法就相当于用自定义的`obj.valueOf`，覆盖`Object.prototype.valueOf`。

- `Object.prototype.toString()`：返回当前对象对应的字符串形式。

  `toString`方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。

  ```js
  var o1 = new Object();
  o1.toString() // "[object Object]"
  
  var o2 = {a:1};
  o2.toString() // "[object Object]"
  ```

  上面代码表示，对于一个对象调用`toString`方法，会返回字符串`[object Object]`，该字符串说明是对象的类型。

  **toString() 的应用：判断数据类型**

  `Object.prototype.toString`方法返回对象的类型字符串，因此可以用来判断一个值的类型。

  ```js
  var obj = {};
  obj.toString() // "[object Object]"
  ```

  由于实例对象可能自定义`toString`方法，覆盖掉`Object.prototype.toString`方法，所以为了得到类型字符串，最好直接使用`Object.prototype.toString`方法，所以为了得到类型字符串，最好直接使用`Object.prototype.toString`方法。通过函数的`call`方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。

  ```js
  Object.prototype.toString.call(value)
  
  Object.prototype.toString.call(2) // "[object Number]"
  Object.prototype.toString.call('') // "[object String]"
  Object.prototype.toString.call(true) // "[object Boolean]"
  Object.prototype.toString.call(undefined) // "[object Undefined]"
  Object.prototype.toString.call(null) // "[object Null]"
  Object.prototype.toString.call(Math) // "[object Math]"
  Object.prototype.toString.call({}) // "[object Object]"
  Object.prototype.toString.call([]) // "[object Array]"
  ```

- `Object.prototype.toLocaleString()`：返回当前对象对应的本地字符串形式。

  `Object.prototype.toLocaleString`方法与`toString`的返回结果相同，也是返回一个值的字符串形式。

  ```js
  var obj = {};
  obj.toString(obj) // "[object Object]"
  obj.toLocaleString(obj) // "[object Object]"
  ```

  这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的`toLocaleString`，用来返回针对某些地域的特定的值。

  ```js
  var person = {
    toString: function () {
      return 'Henry Norman Bethune';
    },
    toLocaleString: function () {
      return '白求恩';
    }
  };
  
  person.toString() // Henry Norman Bethune
  person.toLocaleString() // 白求恩
  ```

  上面代码中，`toString()`方法返回对象的一般字符串形式，`toLocaleString()`方法返回本地的字符串形式。

- `Object.prototype.hasOwnProperty()`：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。

  `Object.prototype.hasOwnProperty()`方法接收一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性

  ```js
  var obj = {
    p: 123
  };
  
  obj.hasOwnProperty('p') // true
  obj.hasOwnProperty('toString') // false
  ```

  上面代码中，对象`obj`自身具有`p`属性，所以返回`true`。`toString`属性是继承的，所以返回`false`。

- `Object.prototype.isPrototypeOf()`：判断当前对象是否为另一个对象的原型。

- `Object.prototype.propertyIsEnumerable()`：判断某个属性是否可枚举。

### 12）获取原型对象的方法

获取实例对象`obj`的原型对象，有三种方法。

- `obj.__proto__`
- `obj.constructor.prototype`
- `Object.getPrototypeOf(obj)`

上面三种方法中，前两种都不是很可靠，`__proto__`属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype 在手动改变原型对象时，可能会失效

```js
var P = function(){};
var p = new P();

var C = function(){};
C.prototype = p;
var c = new C();

c.constructor.prototype === p;//false
```

上面代码中，构造函数`C`的原型对象被改成了`p`，但是实例对象的`c.constructor.prototype`却没有指向`p`。所以，在改变原型对象时，一般要同时设置`constructor`属性。

```js
C.prototype = p;
C.prototype.constructor = C;

var c = new C();
c.constructor.prototype === p // true
```

因此，推荐使用第三种`Object.getPrototypeOf`方法，获取原型对象。

```js
var F = function(){};
var f = new F();
Object.getPrototypeOf(f) === F.prototype;
```

上面代码中，实例对象`f`的原型是`F.prototype`。

下面是几种特殊对象的原型

```js
// 空对象的原型是 Object.prototype
Object.getPrototypeOf({}) === Object.prototype // true

// Object.prototype 的原型是 null
Object.getPrototypeOf(Object.prototype) === null // true

// 函数的原型是 Function.prototype
function f() {}
Object.getPrototypeOf(f) === Function.prototype // true
```

### 13) 回调函数

回调函数是异步操作最基本的方法

下面是两个函数`f1`和`f2`，编程的意图是`f2`必须等到`f1`执行完成，才能执行。

```js
function f1() {
  // ...
}

function f2() {
  // ...
}

f1();
f2();
```

上面代码的问题：如果f1的异步操作，f2会立即执行，不会等到f1执行结束再执行。

这时，可以考虑改写f1，把f2写成f1的回调函数

```js
function f1(callback) {
    //....
    callback()
}

function f2(){
    //....
}

f1(f2)
```

### 14）定时器

#### setTimeout()

​	`setTimeout`函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。

​	如果回调函数是对象的方法，那么`setTimeout`使得方法内部的`this`关键字指向全局环境，而不是定义时所在的那个对象。

```js
var x = 123
var obj = {
    x:2,
    y:function(){
        console.log(this.x)
    }
}
setTimeout(obj.y,1000);//123
//上面代码输出的是123，而不是2。因为当obj.y在1000毫秒后运行时，this所指向的已经不是obj了，而是全局环境。
```

为了防止出现这个问题，一种解决方法是将`obj.y`放入一个函数。

```js
var x = 123
var obj = {
    x:2,
    y:function(){
        console.log(this.x)
    }
}
setTimeout(function(){
    obj.y()
},1000)
//2
//上面代码中，obj.y放在一个匿名函数之中，这使得obj.y在obj的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。
```

另一种解决方法是，使用`bind`方法，将`obj.y`这个方法绑定在`obj`上面。

```js
var x = 1;

var obj = {
  x: 2,
  y: function () {
    console.log(this.x);
  }
};
setTimeout(obj.y.bind(obj), 1000)
//2
```

#### setInterval()

​	`setInterval`函数的用法与`setTimeout`完全一致，区别仅仅在于`setInterval`指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。

```js
var i = 1
var timer = setInterval(function() {
  console.log(2);
}, 1000)
```

上面代码中，每隔1000毫秒就输出一个2，会无限运行下去，直到关闭当前窗口。

#### clearTimeout()，clearInterval()

​	`setTimeout`和`setInterval`函数，都返回一个整数值，表示计数器编号。将该整数传入`clearTimeout`和`clearInterval`函数，就可以取消对应的定时器。

```js
var id1 = setTimeout(f, 1000);
var id2 = setInterval(f, 1000);

clearTimeout(id1);
clearInterval(id2);
//上面代码中，回调函数`f`不会再执行了，因为两个定时器都被取消了。
```

### 15）JavaScript 中，暴露（即向外部公开）模块有三种常见的方式

1. 默认暴露（default export）：一个模块只能默认暴露一次，通过 export default 语法来实现，默认暴露的模块在导入时可以使用任意名称进行引入。

例如：
```javascript
// export-default.js
const defaultExport = {
  name: 'John',
  age: 30
};
export default defaultExport;

// import-default.js
import person from './export-default';
console.log(person.name); // 'John'
```

2. 分别暴露（named exports）：通过 export 语法分别暴露模块中的多个对象、函数、变量等，需要使用相应的名称进行引入。

例如：
```javascript
// export-named.js
export const name = 'John';
export const age = 30;

// import-named.js
import { name, age } from './export-named';
console.log(name); // 'John'
console.log(age);  // 30
```

3. 统一暴露（named exports）：通过 export 语法统一暴露模块中的多个对象、函数、变量等，需要使用相应的名称进行引入。

例如：
```javascript
// export-named.js
const name = 'John';
const age = 30;
export { name, age };

// import-named.js
import { name, age } from './export-named';
console.log(name); // 'John'
console.log(age);  // 30
```

这些是 JavaScript 中常见的暴露模块的方式，具体的选择取决于你的需求和实际情况。
